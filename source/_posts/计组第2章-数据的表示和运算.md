---
title: 计组第2章-数据的表示和运算
date: 2022-07-27 15:13:21
tags: [计算机组成原理]
mathjax: true
typora-root-url: ..
---

### 第二章 数据的表示和运算

#### 考纲内容

>（一）数制与编码
>
>​		进位计数制及其相互转换；定点数的编码表示
>
>（二）运算方法和运算电路
>
>​		基本运算部件：加法器，算术逻辑单元（ALU）
>
>​		加/减运算：补码加/减运算器，标志位的生成
>
>​		乘/除运算：乘/除运算的基本原理，乘法运算和除法电路的基本结构
>
>（三）整数的表示和运算
>
>​		无符号整数的表示和运算；带符号整数的表示和运算
>
>（四）浮点数的表示和运算
>
>浮点数的表示：IEEE754标准；浮点数的加/减运算



#### 一、数制与编码

##### 1.进位计数制及其相互转换

在进位计数法中，一个数由若干个**数位**组成，每个数位都有其**基数**与**位权**。

这个数的十进制值由各个数位上的基数按位权展开并相加得到，称为**按权展开相加法**。

###### (1) 二进制与八进制、十六进制的转换

一个二进制数（即一个二进制位）可以表示的数只有0和1两个，而一个八进制数可以表示的数有0~7共八个，刚好可以由3个二进制位来完全表示（`2**3=8`），故1个八进制位可以转换为3个二进制位，同理，1个十六进制位可以转换为4个二进制位。

而十六进制和八进制的相互转换可以通过二进制作为过渡。

###### (2) 任意进制数转换为十进制数

将任意进制数各个数位上的基数与它们的权值相乘，再把乘积累加，即可得到其十进制值，即按权展开相加法。

###### (3) 十进制数转换为任意进制数

整数部分：除基取余法。（自下向上）

小数部分：乘基取整法。（自上向下）

<img src="/images/计组第2章-数据的表示和运算/image-20220708135843597.png" alt=""  />

##### 2.定点数的编码表示

**真值和机器数：以(+)(-)号来表示正负的数称为真值，以0和1来表示正负的称为机器数。**

BCD码：二进制编码的十进制数，有`2**4-10=6`位冗余，常见的BCD码有8421码。

1.机器数的定点表示

定点数与浮点数相对，包含定点小数和定点整数，定点小数即纯小数，范围在（-1,1）内，其整数部分为0，定点整数即纯整数，其小数部分为0。

定点小数的小数点位置在符号位之后，有效数值部分最高位之前；定点整数小数点在有效数值部分最低位之后。

定点数的编码表示主要有四种：原码、反码、补码、移码。

###### (1) 原码(Sign-Magnitude)

**用机器数的最高位表示数的符号，0代替正号，1代替负号，其余各位不变，即得真值的原码。**

当真值为正数时，最高位为0，故`真值x = 原码[x]`

当真值为负数时，其最高位为1，记真值为x(x<0,包含负号)

> 如果是整数，权值为`2**n`,n为整数位数，故`[x]原 = 2**n + |x|`
>
> 如果是小数，权值为`2**0 = 1`,设小数位数为n，则`[x]原 = 1 + |x| `

**原码最高有效位是符号位，没有权值，仅用来确定剩下的位应该取正权还是负权**：
$$
B2S_{w}(\vec{x})=(-1)^{x_{w-1}}(\sum_{i=0}^{w-2}x_{i}2^{i})
$$
原码表示范围：$SMin_{w}=[1,111\cdot\cdot\cdot1]=-2^{w-1}+1$,$SMax_{w}=[0,111\cdot\cdot\cdot1]=2^{w-1}-1$,关于原点对称。

###### (2) 补码(Two's-complement)

**补码的最高位为负权**，其余各位为正权，最高位为0代表正数，最高位为1代表负数。

对于向量
$$
\vec{x}=[x_{w-1},x_{w-2},\cdot\cdot\cdot,x_{0}]:
$$

$$
B2T_{w}(\vec{x})=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}
$$

$B2T_{w}$（Binary to Two's-complement，二进制转化为二进制的补码：将真值（二进制向量）的最高位权重取负，再与其余各数位按权展开相加，即可得到其补码的十进制值，根据除2取余法即可转换为二进制形式的补码，该补码位数不足8位时，正数最高位补0，负数最高位补1，其余位补0）。**补码的最高有效位 $x_{w-1}$也称为符号位，它的权重为$-2^{w-1}$。**

当真值x为正数时，$x_{w-1}=0$,故$[x]补=\sum_{i=0}^{w-2}x_{i}2^{i}=真值x$;

当真值x为负数时，$x_{w-1}=1$, $B2T_{w}(\vec{x})=-2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}$,

如果是整数，真值的绝对值$|x|=[x]补+x_{w-1}2^{w}$，即相差了两个$x_{w-1}2^{w-1}$。

补码所能表示的范围：$TMin_{w}=[1,0,0,0,\cdot\cdot\cdot,0]=-2^{w-1}$,$TMax_{w}=[0,1,1,1,\cdot\cdot\cdot,1]=2^{w-1}-1$。

$TMax_{w}=-TMin_{w}-1$,补码的范围是不对称的，$TMin_{w}$没有与之对应的正数。

###### (3)  反码(One's Complement)

除了最高有效位的权是$-(2^{w-1}-1)$而不是$-2^{w-1}$,它和补码是一样的：
$$
B2O_{w}(\vec{x})=-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_{i}2^{i}
$$
由原码求反码：符号位不变，尾数取反；

由反码求补码：末位+1；

**故由原码求补码：符号位不变，尾数取反，末位加一。**

###### (4)  移码

**移码和补码：符号位相反，数值位相同。**

移码全0时，对应真值的最小值$-2^{n}$,移码全1时，对应真值的最大值$2^{n}-1$。

移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。

###### (5) 原码、反码、补码、移码总结：

- 原码、补码、反码的符号位相同，正数的机器数相同；
- 原码、反码的表示在数轴上对称，二者都存在+0和-0两个零；
- 补码、移码不对称，0的表示唯一，它们比原码、反码多出一个位置来表示一个数；
- **将真值的(+)(-)负号用0和1来表示即得真值的原码；原码符号位不变、尾数取反即得反码；反码末位+1即得补码；补码符号位取反即得移码；**
- **补码和真值的相互转换：连同符号位一起取反，末位加1。**
- **[x]补转换为[-x]补：各位取反，末位+1。**



#### 二、运算方法和运算电路

##### 1.基本运算部件

在计算机中，运算器是由算术逻辑单元ALU、移位器、状态寄存器、和通用寄存器等组成。运算器的基本功能包括加、减、乘、除四则运算，与、或、非、异或等逻辑运算以及移位、求补等操作。ALU的核心部件是加法器。

###### (1) 一位全加器

<img src="/images/计组第2章-数据的表示和运算/image-20220706171044267.png" alt="" style="zoom:50%;" />

全加器（FA）是最基本的加法单元，有加数A加数B与低位传来的进位$C_{i-1}$共三个输入，有本位和$S_{i}$和向高位的进位$C_{i}$共两个输出。全加器的逻辑表达式如下：

和表达式：$S_{i}=A_{i}⊕B_{i}⊕C_{i-1}$（有奇数个1时，$S_{i}=1$;否则$S_{i}=0$）

进位表达式：$C_{i}=A_{i}B_{i}+(A_{i}⊕B_{i})C_{i-1}$

###### (2) 串行进位加法器

把n个加法器相连可以得到n位加法器，称为串行进位加法器。串行进位加法器是实现了两个n位二进制数$A=A_{n}A_{n-1}\cdot\cdot\cdot A_{1}$和$B=B_{n}B_{n-1}\cdot\cdot\cdot B_{1}$逐位相加的功能。

<img src="/images/计组第2章-数据的表示和运算/image-20220706172746396.png" alt="" style="zoom:50%;" />

得到的和为$S=S_{n}S_{n-1}\cdot\cdot\cdot S_{1}$,进位输出为$C_{n}$.

由于加法器位数有限，如果超过了最高位数，高位自动丢失，所以实际是模$2^{n}$的加法运算。

在串行进位加法器中，低位运算所产生进位所需的时间将影响高位运算的时间。串行进位加法器的最长运算时间主要是由进位信号的传递时间决定的，位数越多延迟时间越长，而全加器本身的求和延迟只是次要因素，因此加快进位产生和提高传递的速度是提升性能的关键。

###### (3) 并行进位加法器

**令$G_{i}=A_{i}B_{i}$,称为进位产生函数，即进位信号；$P_{i}=A_{i}⊕B_{i}$,称为进位传递函数，即进位传递信号。**

$C_{i}$仅与$A_{i}$、$B_{i}$和最低进位$C_{0}$有关，相互间的进位没有依赖关系。只要$A_{1}$~$A_{n}$ ,$B_{1}$~$B_{n}$和$C_{0}$同时到达，就可以几乎同时形成$C_{1}$ ~ $C_{4}$,并且同时生成各位的和。

实现上述逻辑的电路称为先行进位部件，简称CLA部件。通过这种进位方式实现的加法器称为全先行进位加法器。

<img src="/images/计组第2章-数据的表示和运算/image-20220727212359897.png" style="zoom:80%;" />

这种进位方式是快速的，与位数无关。但随着加法器位数的增加，$C_{i}$的逻辑表达式会变得越来越长，这会使电路结构越来越复杂，所以可以将加法器部件先分组，采取组内并行进位，组间再并行进位的方式，可以控制每个部分的复杂性，同时也进一步提高了运算速度。

###### (4) 带标志加法器

<img src="/images/计组第2章-数据的表示和运算/image-20220727212622458.png" style="zoom:80%;" />

在无符号加法器的基础上添加了溢出标志OF，符号标志SF，零标志ZF，进位/借位标志CF。值得注意的是，为了加快加法运算的速度，实际电路一定使用多级先行进位方式。

###### (5) 算术逻辑单元ALU

ALU的核心是带标志加法器，同时也能执行与或非等逻辑运算。ALU基本结构如图所示，`ALUop`是操作控制端，用来决定ALU所执行的处理功能，`ALUop`的位数决定了操作的种类数量。

MUX是多路选择开关，它从多个输入信号中选择一个送到输出端。

<img src="/images/计组第2章-数据的表示和运算/image-20220727212743794.png" style="zoom:80%;" />

##### 2.定点数的移位运算

###### (1) 算术移位

**算术移位：符号位不变、数码位置变化**。

算术移位的对象是有符号数，在移位过程中符号位保持不变。

对于正数，由于`原码 = 反码 = 补码 = 真值`，因此移位后出现的空位全部补0。对于负数，因为原码、反码、补码的表示形式不同，因此当机器数移位时，对其空位的添补规则也不同。

>注意：不论是正数还是负数，移位后其符号位均不变，且移位后都相当于对真值补0。

负数的算术移位添补规则：

|      | 码制             | 添补代码         |
| ---- | ---------------- | :--------------- |
| 正数 | 原码、反码、补码 | 0                |
|      | 原码             | 0                |
| 负数 | 反码             | 左移添0，右移添1 |
|      | 补码             | 1                |

###### (2) 逻辑移位

**逻辑移位：数码位置变化。**

逻辑移位时将操作数视为无符号数。

移位规则：逻辑左移时，高位移丢，低位添0；逻辑右移时，低位移丢，高位添0。

<img src="/images/计组第2章-数据的表示和运算/image-20220706191610089.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220706191752334.png" alt=""  />

###### (3) 循环移位

循环移位分为带进位标志位CF的循环移位和不带进位标志位的循环移位。循环移位的主要特点是，移出的数位又被移入数据中。循环移位适合于将数据的低字节数据和高字节数据互换。

##### 3.定点数的加减运算

###### (1) 补码的加减法运算

定点数一般用补码表示，符号位参与运算。

<img src="/images/计组第2章-数据的表示和运算/image-20220706195529993.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220706195624577.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220706195651109.png" alt=""  />

###### (2) 补码加减运算电路

<img src="/images/计组第2章-数据的表示和运算/image-20220706195752856.png" alt=""  />

###### (3) 溢出判断方法

<img src="/images/计组第2章-数据的表示和运算/image-20220706200603460.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220706200618745.png" alt=""  />

逻辑一（根据符号判断）：无论是加法还是减法，只要**参加操作的两个数符号相同，结果又与原操作数符号不同**，则表示结果溢出。

根据溢出逻辑表达式，当溢出逻辑V=0时，表示无溢出；当溢出逻辑V=1时，表示有溢出。

逻辑二（根据进位判断）：若符号位的进位$C_{f}$与最高数位的进位C相同，$V=C_{f}⊕C=0$表示无溢出，**若符号位的进位与最高位的进位不一致，V=1表示有溢出。**

逻辑三（根据双符号位判断）：采用双符号位时，若结果的两个符号位相同，$V=S_{f1}⊕S_{f2}=0$,表示无溢出，V=1表示溢出。**01表示正溢，10表示负溢。**

###### (4) 原码的加减法运算

<img src="/images/计组第2章-数据的表示和运算/image-20220706202418827.png" alt=""  />

 ##### 4.定点数的乘除运算

###### (1) ◓原码一位乘法

<img src="/images/计组第2章-数据的表示和运算/image-20220706205641762.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220706205701414.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220706205722544.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220706205738465.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220706205754110.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220706205806670.png" alt=""  />

###### (2) 无符号数乘法运算电路

<img src="/images/计组第2章-数据的表示和运算/image-20220707090213305.png" alt=""  />

###### (3) 补码一位乘法

补码一位乘法是有符号数的乘法，采用相加和相减操作计算补码数据的乘积。

设$[X]补=x_{s}\cdot x_{1}x_{2}\cdot\cdot\cdot x_{n}$,$[Y]补=y_{s}\cdot y_{2}y_{2}\cdot\cdot\cdot y_{n}$,则运算规则如下：

- 符号位参与运算，运算的数均以补码表示。
- 被乘数一般取双符号位参与运算，部分积取双符号位，初始值为0，乘数取单符号位。
- 乘数末位增设附加位$y_{n+1}$,初始值为0。
- 根据$y_{n}y_{n+1}$的取值来确定操作，见下图。

<img src="/images/计组第2章-数据的表示和运算/image-20220707090920563.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220707090936191.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220707090947715.png" alt=""  />

###### (4) 符号扩展

1. **无符号数使用零扩展**
2. **补码数使用符号扩展**

<img src="/images/计组第2章-数据的表示和运算/image-20220707093540297.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220707093601666.png" alt=""  />

###### (5) 原码除法运算

![](/images/计组第2章-数据的表示和运算/image-20220727221403134.png)

###### (6) ◒补码不恢复余数除法

补码一位除法的特点是，符号位与数值位一起参与运算，商符自然形成。

除法第一步根据被除数和除数的符号决定做加法还是减法；上商的原则根据余数和被除数的符号位共同决定，同号上商"1"，异号上商"0"；最后一步商恒置"1"。

加减法的交替规则如下：

1. 符号位参与运算，除数、被除数以及商和余数均用补码表示。
2. 若被除数与除数同号，则被除数减去除数；若被除数与除数异号，则被除数加上除数。
3. **若余数与除数同号，则商上"1"，余数左移一位减去除数；若异号则商上"0"，余数左移一位加上除数。**
4. 重复执行第3步n次。
5. 若对商的精度没有要求，则一般采用”末位恒置1“法。

<img src="/images/计组第2章-数据的表示和运算/image-20220707095952702.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220707100006747.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220707100018482.png" alt=""  />

###### (7) 除法运算电路

![](/images/计组第2章-数据的表示和运算/image-20220727221206654.png)



##### 5.C语言整数类型转换

###### (1) 有符号数和无符号数的转换

1. 强制类型转换的原理

C语言允许在不同的数据类型之间进行强制类型转换。

```c
int main(){
    short x=-4321;
    unsigned short y=(unsigned short)x;
    printf("x=%d, y=%u\n",x,y);
}
```

在采用补码的机器上，上述代码会输出如下结果：

```
x=-4321,y=61215
```

这两个值看似没有任何关系，不过将它们转换为二进制表示时，我们就会发现其中的规律：

```c
x=11111111111111111110111100011111
y=                1110111100011111
```

可以发现x和y的二进制表示是一致的，只不过x进行了符号扩展。

因此，**强制类型转换的结果保持位值不变，仅改变了解释这些位值的方式。**

2. 有符号数与无符号数的相互转换方式

【2016统考真题】有如下C语言程序段：

```c
short si = -32767;
unsigned short usi = si;
```

执行上述两条语句后，`usi`的值为（  ）。

```
A. -32767	B. 32767	C. 32768	D. 32769
```

【2019统考真题】考虑以下C语言代码：

```c
unsigned short usi = 65535;
short si = usi;
```

执行上述程序段后，`si`的值是（  ）。

```
A. -1	B. -32767	C. -32768	D. -65535
```

【分析】：这两个题都是对无符号数与有符号数的相互转换的考察，我们要熟悉无符号数与有符号数的表示范围与转换规则。

<img src="/images/计组第2章-数据的表示和运算/image-20220707213217903.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220707213230541.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220707213451081.png" alt=""  />

###### (2) 不同字长整数之间的转换

1. 当大字长变量向小字长变量强制类型转换时，系统把多余的高位部分直接**截断**，低位直接赋值，因此也是一种保持位值的方法；
2. 短字长整数到长字长整数的转换时，不仅要使相应的位值相等，还要对高位部分进行扩展。如果原数字是无符号整数，则进行**零扩展**，否则进行**符号扩展**。

##### 6.数据的存储和排列

###### (1) 大端法和小端法

<img src="/images/计组第2章-数据的表示和运算/image-20220707135807966.png" alt=""  /> 

###### (2) 数据按边界对齐存储

当告诉我们按字节编址时，即每个字节都有其地址；当告诉我们机器字长为32位时，即一个机器字包含4个字节，注意数据存储是否按机器字的边界对齐。

<img src="/images/计组第2章-数据的表示和运算/image-20220707135940966.png" alt=""  />

数据以按边界对齐方式存放可以一次访存取出，所存储的数据不能恰好按边界对齐时，可以填补空白字节，使之按边界对齐，这样虽然浪费了一些存储空间，但可以提高取指令和取数的速度。

##### 7.浮点数的表示与运算

<img src="/images/计组第2章-数据的表示和运算/image-20220708175817299.png" alt=""  />

<img src="/images/计组第2章-数据的表示和运算/image-20220708175911661.png" alt=""  />

###### (1) 浮点数的表示格式

通常，浮点数表示为
$$
N=(-1)^{S}×M×R^{E}
$$
其中，S为数符，取值0或1，用来决定浮点数的符号；

M是尾数，为二进制定点小数，一般用定点原码小数表示，尾数的位数反映浮点数的精度；

R为基数，二进制基数R=2；

E为阶码，即指数，用移码表示。阶码的值反映浮点数的小数点的实际位置，阶码的位数反映浮点数的表示范围。

<img src="/images/计组第2章-数据的表示和运算/image-20220708093014957.png" alt=""  />

###### (2) 浮点数的规格化

规格化：约定尾数M的值域，使浮点数的表示代码是唯一的、确定的。

所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值（十进制），即阶码的位模式既不全为0，也不全为1。

当阶码的位模式全为0时，说明尾数M过小，尾数的最高数位不是有效位，应该对尾数M进行左规，尾数每左移一位，阶码减1（基数为2时）；

<img src="/images/计组第2章-数据的表示和运算/image-20220708102345481.png" alt=""  />

尾数是纯小数，M＜1，当运算结果的尾数的小数位进到小数点前面时，需要进行右规，将尾数右移一位阶码加1（基数为2时），需要右规时，只需进行一次，左规可能要进行多次。

当阶码全为1时，表明该数是一个特殊值，可能为$+∞$、$-∞$或`NaN`(Not a Number)。

<img src="/images/计组第2章-数据的表示和运算/image-20220708093703792.png" alt=""  />

###### (3) IEEE754标准

按照IEEE754标准，常用的浮点数格式如下：

<img src="/images/计组第2章-数据的表示和运算/image-20220708102215311.png" alt=""  />

32位单精度格式：1位符号+8位阶码+23位尾数

64位双精度格式：1位符号+11位阶码+52位尾数

IEEE754标准的长短浮点数，是尾数采取隐藏位策略的原码表示，且阶码用移码表示的浮点数。

对于规格化的二进制浮点数，数值的最高位总是"1"，既然第一位总是"1"，那么我们就不需要显式地表示它，将这个"1"隐藏，称为隐藏位，因此23位尾数可以表示出24位有效数字。

短浮点数与长浮点数都采用隐藏尾数最高数位的方法，因此可以多表示一位尾数。

对于短浮点数，偏置值为127；对于长浮点数，偏置值为1023。存储浮点数阶码之前，偏置值要先加到阶码真值上。因此，IEEE754标准中，规格化短浮点数的真值为：
$$
(-1)^{S}×1.M×2^{E-127}
$$
规格化长浮点数的真值为：
$$
(-1)^{S}×1.M×2^{E-1023}
$$

###### (4) 定点、浮点表示的区别

若定点数与浮点数的字长相同，则浮点数所能表示的范围更大，但精度更低；

在定点运算中，当运算结果超出数的表示范围时，发生溢出；浮点运算中，运算结果超出尾数的表示范围却不一定溢出，只有当规格化后阶码超出所能表示的范围时，才发生溢出。

###### (5) 浮点数的加减运算

浮点数加减运算的特点是阶码运算与尾数运算分开进行，浮点数运算分为以下几步：

1. 对阶

   对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。

   为此，先求差，然后以小阶向大阶看齐的原则，将阶码小的尾数右移，每移一位阶加1，直到两个数的阶码相等为止。尾数右移时，舍弃掉有效位会产生误差，影响精度。

2. 尾数求和

   将对阶后的尾数按定点数加减法运算规则运算。尾数以原码表示，即进行原码加减法运算，或将原码转换为补码运算后，再将结果转换回原码。

3. 规格化

   运算后的尾数不一定是规格化的，需要进一步进行规格化处理。左规一次相当于乘2，右规一次相当于除以2，需要右规时，只需进行1次。

4. 舍入

   0舍1入法；

   末位恒置1法；

   截断法。

5. 溢出判断

   <img src="/images/计组第2章-数据的表示和运算/image-20220708114926685.png" alt=""  />

###### (6) C语言中的浮点数类型

C语言中的`float`和`double`类型分别对应于IEEE754单精度浮点数和双精度浮点数，`long double`类型对应于扩展双精度浮点数。在C程序中等式的赋值和判断中会出现强制类型转换，以`char->int->long->double`和`float->double`最为常见，从前到后范围和精度都从小到大，转换过程没有损失。

`int`转换为`float`时，两者都是4个字节，不会发生溢出，但是由于`float`尾数连隐藏位一共24位，当`int`型数的第24~31位非0时，无法精确转换为24位浮点数的尾数，需要进行舍入处理，影响精度。

`float`或`double`类型转换为`int`时，会直接截断，仅保留整数部分。另外`int`表示范围更小，有可能会溢出。


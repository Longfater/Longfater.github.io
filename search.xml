<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计组第3章-存储系统</title>
      <link href="/2022/07/27/ji-zu-di-3-zhang-cun-chu-xi-tong/"/>
      <url>/2022/07/27/ji-zu-di-3-zhang-cun-chu-xi-tong/</url>
      
        <content type="html"><![CDATA[<h3 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h3><h4 id="考纲内容"><a href="#考纲内容" class="headerlink" title="考纲内容"></a>考纲内容</h4><blockquote><p>（一）存储器的分类</p><p>（二）层次化存储器的基本结构</p><p>（三）半导体随机存储器</p><p>​        SRAM、DRAM、Flash存储器</p><p>（四）主存储器</p><p>​        DRAM芯片与内存条、多模块存储器、主存和CPU之间的连接</p><p>（五）外部存储器</p><p>​        磁盘存储器、固态硬盘（SSD）</p><p>（六）高速缓冲存储器（Cache）</p><p>​        Cache的基本原理；Cache和主存之间的映射方式</p><p>​        Cache中主存块的替换算法；Cache写策略</p><p>（七）虚拟存储器</p><p>​        虚拟存储器的基本概念</p><p>​        页式虚拟存储器：基本原理、页表、地址转换、TLB（快表）</p><p>​        段式虚拟存储器的基本原理；段页式虚拟存储器的基本原理</p></blockquote><h4 id="3-1-存储器概述"><a href="#3-1-存储器概述" class="headerlink" title="3.1 存储器概述"></a>3.1 存储器概述</h4><h5 id="1-存储器的层次结构"><a href="#1-存储器的层次结构" class="headerlink" title="1. 存储器的层次结构"></a>1. 存储器的层次结构</h5><p><img src="/images/计组第3章-存储系统/image-20220710162950624.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710163119440.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710163158290.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710164124133.png" alt=""></p><p>实际上，存储器层次结构主要体现在<code>Cache—主存层</code>和<code>主存—辅存层</code>，前者主要解决<strong>CPU和主存速度不匹配的问题</strong>，后者主要解决<strong>存储系统的容量问题</strong>。在存储体系中，Cache、主存能够与CPU直接交换信息，辅存则要通过主存与CPU交换信息。存储器层次结构的主要思想是上一层存储器作为低一层存储器的高速缓存，上一层内容只是下一层经常使用到的内容的副本。</p><h5 id="2-存储器的分类"><a href="#2-存储器的分类" class="headerlink" title="2. 存储器的分类"></a>2. 存储器的分类</h5><ul><li>按存储介质分类：半导体存储器、磁表面存储器、光存储器</li><li>按存取方式分类：随机存取存储器(RAM、ROM)、顺序存取存储器(磁带)、直接存取存储器(磁盘、光盘)</li></ul><p><img src="/images/计组第3章-存储系统/image-20220710165435322.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710165509725.png" alt=""></p><p><strong>顺序存取存储器（SAM）</strong>：磁带、电影胶片</p><p>访问时，读/写部件按顺序查找目标地址，访问时间与数据的存储位置有关。</p><p><strong>直接存取存储器（DAM）</strong>：硬盘</p><p>访问时，读/写部件先粗定位一个小区域，再在该区域内顺序查找。</p><h5 id="3-存储器的性能指标"><a href="#3-存储器的性能指标" class="headerlink" title="3. 存储器的性能指标"></a>3. 存储器的性能指标</h5><ul><li>存储容量 = 存储字数 × 字长</li><li>单位成本：每位价格 = 总成本/总容量</li><li>存储速度：<strong>数据传输率 = 数据的宽度/存储周期</strong><ul><li>存取时间：存储器收到读写命令到存储器读出/写入信息所需要的时间</li><li>存取周期：<strong>存取周期 = 存取时间 + 恢复期</strong></li><li>主存带宽：又称为数据传输率</li></ul></li></ul><p><img src="/images/计组第3章-存储系统/image-20220711152647054.png" alt=""></p><h4 id="3-2-主存储器"><a href="#3-2-主存储器" class="headerlink" title="3.2 主存储器"></a>3.2 主存储器</h4><h5 id="1-SRAM芯片和DRAM芯片"><a href="#1-SRAM芯片和DRAM芯片" class="headerlink" title="1. SRAM芯片和DRAM芯片"></a>1. SRAM芯片和DRAM芯片</h5><h6 id="1-SRAM的工作原理"><a href="#1-SRAM的工作原理" class="headerlink" title="1. SRAM的工作原理"></a>1. SRAM的工作原理</h6><p><img src="/images/计组第3章-存储系统/image-20220710170638568.png" alt=""></p><p>通常把存放一个二进制位的物理器件称为存储元，它是存储器最基本的结构。</p><p><strong>静态随机存储器SRAM的存储元是双稳态触发器（六晶体管MOS），依靠双稳态电路内部交叉反馈电路形成互锁，通过电源对电路的持续供电以存储信息，不需要刷新，为非破坏性读出，不需要重写。</strong></p><p><img src="/images/计组第3章-存储系统/image-20220710171018980.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710171508165.png" alt=""></p><h6 id="2-DRAM的工作原理"><a href="#2-DRAM的工作原理" class="headerlink" title="2. DRAM的工作原理"></a>2. DRAM的工作原理</h6><p><strong>动态随机访问存储器DRAM依靠存储单元中形成的栅极电容来保存信息，不需要持续电源，因此需要定期逐行刷新。</strong>MOS：金属氧化物半导体，加高电平即导通，低电平即阻断。</p><p><img src="/images/计组第3章-存储系统/image-20220710172412606.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710172450820.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710172518487.png" alt=""></p><p><strong>动态存储器的刷新：</strong></p><p><strong>定期向电容补充电荷叫做刷新。</strong>因为动态存储器依靠电容电荷存储信息，没有电源持续供电，电荷会泄露，故需定期向电容补充电荷，才能维持存储信息不变。</p><p><img src="/images/计组第3章-存储系统/image-20220710175156513.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710175305647.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710175332757.png" alt=""></p><h6 id="3-DRAM芯片读写周期"><a href="#3-DRAM芯片读写周期" class="headerlink" title="3. DRAM芯片读写周期"></a>3. DRAM芯片读写周期</h6><p><img src="/images/计组第3章-存储系统/image-20220710184205175.png" alt=""></p><h6 id="4-SRAM与DRAM的比较"><a href="#4-SRAM与DRAM的比较" class="headerlink" title="4. SRAM与DRAM的比较"></a>4. SRAM与DRAM的比较</h6><p><img src="/images/计组第3章-存储系统/image-20220710184607749.png" alt=""></p><h6 id="5-存储器芯片的内部结构"><a href="#5-存储器芯片的内部结构" class="headerlink" title="5. 存储器芯片的内部结构"></a>5. 存储器芯片的内部结构</h6><p><img src="/images/计组第3章-存储系统/image-20220724162255581.png" alt=""></p><ol><li>存储体（存储矩阵 ）。存储体是存储单元的集合，它由行选择线(X)和列选择线(Y)来选择所访问单元，存储体上的相同行、列上的位同时被读出或写入。</li><li>地址译码器：用来将地址转换为译码输出线上的高电平，以便驱动相应的读写电路。</li><li>I/O控制电路：用以控制被选中单元的读出或写入，具有放大信息的作用。</li><li>片选控制信号。</li><li>读/写控制信号。</li></ol><h6 id="6-半导体存储器的逻辑设计"><a href="#6-半导体存储器的逻辑设计" class="headerlink" title="6. 半导体存储器的逻辑设计"></a>6. 半导体存储器的逻辑设计</h6><p><img src="/images/计组第3章-存储系统/image-20220710190056581.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710190134519.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710190200719.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710190229562.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710190301146.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710190355822.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220710190421670.png" alt=""></p><h5 id="2-只读存储器ROM"><a href="#2-只读存储器ROM" class="headerlink" title="2. 只读存储器ROM"></a>2. 只读存储器ROM</h5><p>只读存储器（ROM）有两个显著的优点：</p><ul><li>结构简单，所以位密度比可读写存储器高。</li><li>具有<strong>非易失性</strong>，所以可靠性高。</li></ul><p>ROM的类型：</p><ol><li>掩模式只读存储器MROM：内容由半导体制造厂商按用户的需求在芯片生产过程中直接写入，之后无法改变</li><li>一次可编程只读存储器PROM：可以利用专门的设备写入一次，之后内容无法改变。</li><li>可擦除可编程存储器EPROM：可写入几十次，用紫外线照射擦除。</li><li>电擦除型可编程只读存储器EEPROM：使用高压电实现比特级擦除。</li><li>Flash存储器：即闪存，是一种快速擦写型ROM，典型应用有U盘、SSD固态硬盘等。其主要特点是既可在不加电的情况下长期保存信息，又能在线进行快速擦除与重写。</li><li>固态硬盘SSD：基于闪存，保留了Flash存储器长期保存信息、快速擦除与重写的特性，对比传统硬盘也具有读写速度快、低功耗等特点，缺点是价格较高。</li></ol><h5 id="3-主存储器的基本组成"><a href="#3-主存储器的基本组成" class="headerlink" title="3. 主存储器的基本组成"></a>3. 主存储器的基本组成</h5><p><img src="/images/计组第3章-存储系统/image-20220710191407193.png" alt=""></p><p>指令执行过程中需要访问主存时，CPU首先把被访问单元的地址送到地址寄存器MAR中，然后通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器译码选中相应单元，同时CPU将读写信号通过控制线送到主存的读写控制电路。</p><p>如果是写操作，那么CPU同时将要写的信号送入MDR中，在读写控制电路的控制下，经过数据线将信号写入选中的单元；</p><p>若果是读操作，那么主存读出选中单元的内容送到数据线，然后送到MDR中。</p><p><strong>数据线的宽度与MDR的宽度相同，地址线的宽度与MAR的宽度相同。地址线的位数决定了主存地址空间的最大可寻址范围。</strong></p><h5 id="4-多模块存储器"><a href="#4-多模块存储器" class="headerlink" title="4. 多模块存储器"></a>4. 多模块存储器</h5><p>多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块并行工作来提高存储器的吞吐率。常用的有单体多字存储器和多体位交叉存储器。</p><blockquote><p>注意：CPU的速度比存储器快，若同时从存储器中取出n条指令，就可以充分利用CPU资源，提高运行速度。多体交叉存储器就是基于这种思想提出的。</p></blockquote><h6 id="1-单体多字存储器"><a href="#1-单体多字存储器" class="headerlink" title="1. 单体多字存储器"></a>1. 单体多字存储器</h6><p>单体多字存储器的特点是存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。</p><h6 id="2-多体并行存储器"><a href="#2-多体并行存储器" class="headerlink" title="2. 多体并行存储器"></a>2. 多体并行存储器</h6><p>多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。</p><p>多体并行存储器分为高位交叉编址和低位交叉编址。</p><p><strong>高位交叉编址（顺序方式）</strong>：高位地址表示体号，低位地址为体内地址。访问一个连续主存块时总是先在一个模块内访问，等待该模块访问结束才转到下一个模块，各模块不能被并行访问。</p><p><img src="/images/计组第3章-存储系统/image-20220724163124596.png" alt=""></p><p><strong>低位交叉编址（交叉方式）</strong>：低位地址为体号，高位地址为体内地址。每个模块按”模m“编址，模块号=单元地址%m，假定有m个模块，每个模块有k个单元，则$M_{0}=Pm,M_{1}=Pm+1,\cdot\cdot\cdot$,$0=&lt;P&lt;=k+1$。</p><p>低位交叉方式下，总是把高位的体内地址送到由低位地址确定的模块内进行译码，程序连续存放在相邻的模块中，因此称采用此编制方式的存储器为交叉存储器。</p><p><img src="/images/计组第3章-存储系统/image-20220724163237158.png" alt=""></p><p>采用低位交叉编址后，可在不改变每个模块的存取周期的前提下，用流水线的方式并行存取，提高存储器的带宽。</p><p>交叉存取度m = 存取周期T / 总线传送周期r；存储体的模块数必须大于等于m。</p><p>顺序存储器  $t_{1}=m T$</p><p>交叉存储器 $t_{2} = T + (m-1)r$。</p><h5 id="5-本节小结"><a href="#5-本节小结" class="headerlink" title="5. 本节小结"></a>5. 本节小结</h5><ol><li>芯片引脚数 = 地址线数 + 数据线数 + 片选线数 + 读写控制线数</li><li>一根线就是一个二进制位，高电平时为1，低电平时为0</li><li><strong>n根地址线可以表示$2^{n}$个存储单元，故若有$2^{n}$个存储单元，则地址线数 = n</strong></li><li><strong>数据线数 = 存储字长，即1个存储单元的位数</strong></li><li>读写控制线为1或2根，皆有可能，片选线数为1根</li><li>DRAM采用地址引脚复用技术，地址线减半，数据线不变，增加了两根线即行通选和列通选，片选线以行通选代替</li><li>分散刷新延长了存取周期，不存在死时间。</li></ol><h4 id="3-3-主存储器与CPU的连接"><a href="#3-3-主存储器与CPU的连接" class="headerlink" title="3.3 主存储器与CPU的连接"></a>3.3 主存储器与CPU的连接</h4><h5 id="1-连接原理"><a href="#1-连接原理" class="headerlink" title="1. 连接原理"></a>1. 连接原理</h5><p>主存储器通过数据总线、地址总线和控制总线与CPU连接；</p><p>数据总线的位数与工作频率的乘积正比于数据传输率；</p><p>地址总线的位数决定了可寻址的最大内存空间；</p><p>控制总线（读/写）指出总线周期的类型和本次输入/输出操作完成的时刻。</p><h5 id="2-主存容量扩展"><a href="#2-主存容量扩展" class="headerlink" title="2. 主存容量扩展"></a>2. 主存容量扩展</h5><p>由于单个存储芯片的容量是有限的，它在字数或字长方面与实际存储器的需求都有差距，因此需要在字和位两方面进行扩充才能满足实际存储器的容量要求。通常采用位扩展法、字扩展法和字位同时扩展法来扩展主存容量。</p><ol><li><p><strong>位扩展法</strong>：用多个存储器件对字长进行扩充，增加存储字长。位扩展的连接方式是将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出。</p><blockquote><p>注意：仅采用位扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，在某一时刻选中所有的芯片，所以片选信号（CS非）要连接到所有的芯片。</p></blockquote><p><img src="/images/计组第3章-存储系统/image-20220724163553716.png" alt=""></p></li><li><p><strong>字扩展法</strong>：字扩展将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围。</p><blockquote><p>注意：仅采用字扩展时，各芯片连接地址线的方式相同，连接数据线的方式也相同，但在某一时刻只需选中部分芯片，所以通过片选信号（CS非）连接到相应的芯片。</p></blockquote><p><img src="/images/计组第3章-存储系统/image-20220724163643199.png" alt=""></p></li><li><p><strong>字位同时扩展法</strong>：同时增加存储字的数量和存储字长。</p><blockquote><p>数据线的连接方式不同，而且片选信号也要连接到相应的芯片。</p></blockquote><p><img src="/images/计组第3章-存储系统/image-20220724163750209.png" alt=""></p></li></ol><h5 id="3-存储容量的地址分配和片选"><a href="#3-存储容量的地址分配和片选" class="headerlink" title="3. 存储容量的地址分配和片选"></a>3. 存储容量的地址分配和片选</h5><p>CPU要实现对存储单元的访问，首先要进行片选，然后进行字选。</p><p>片选信号的产生分为线选法和译码片选法。</p><ol><li><p><strong>线选法</strong>：用除片内寻址外的高位地址线直接分别连接至各个存储芯片的片选端，当某地址线信号为”0“时，就选中与之对应的存储芯片（CS非低电平有效）。这些片选地址每次寻址时只能有一位有效，保证每次只选中一个芯片。</p><p>优点：不需要地址译码器，线路简单。</p><p>缺点：地址空间不连续，选片的地址必须分时为低电平，不能充分利用系统的存储器空间。</p></li><li><p><strong>译码片选法</strong>：用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号。</p></li></ol><h5 id="4-存储器与CPU的连接"><a href="#4-存储器与CPU的连接" class="headerlink" title="4. 存储器与CPU的连接"></a>4. 存储器与CPU的连接</h5><ol><li>合理选择存储芯片：主要指芯片类型和数量的选择；</li><li>地址线的连接：通常用CPU地址线的低位进行字选，高位进行片选；</li><li>数据线的连接：CPU的数据线数与存储器的数字线数不相等时，必须对存储芯片进行扩位；</li><li>读/写命令线的连接：一般可以直接相连，高电平为读，低电平为写；</li><li>片选线的连接：是CPU与存储芯片连接的关键，存储器有许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端（CS非）能否接收到来自CPU的有效片选信号。</li></ol><h4 id="3-4-外部存储器"><a href="#3-4-外部存储器" class="headerlink" title="3.4 外部存储器"></a>3.4 外部存储器</h4><h5 id="1-磁盘存储器"><a href="#1-磁盘存储器" class="headerlink" title="1. 磁盘存储器"></a>1. 磁盘存储器</h5><ol><li><p>磁盘存储器的优缺点：存储容量大、位价格低；记录介质可重复使用；记录信息可长期保存而不丢失；非破坏性读出，读出时不需要再生；缺点是存取速度慢，机械结构复杂，对工作环境要求较高。</p></li><li><p>磁盘设备的组成：磁盘存储器由磁盘驱动器、磁盘控制器和盘片组成；一块硬盘含有若干记录面，每个记录面划分为若干磁道，而每条磁道又划分为若干扇区，<strong>扇区是磁盘读写的最小单位</strong>。</p></li><li><p>磁头数即记录面数，表示硬盘共有多少个磁头；柱面数表示硬盘每面盘片上有多少条磁道；扇区数表示每条磁道上有多少个扇区。</p></li><li><p>磁记录原理：磁头和磁性记录介质相对运动时，通过电磁转换完成读写操作。</p></li><li><p>磁盘的性能指标：记录密度；磁盘容量；平均存取时间；数据传输率；</p><p>数据传输率=磁盘转速r(转/秒) × 磁道容量N(字节)</p></li><li><p>磁盘地址=驱动器号+柱面(磁道)号+盘面号+扇区号</p></li><li><p>读一个扇区中数据所用的时间 = 找磁道的时间 + 找扇区的时间 + 磁头扫过一个扇区的时间</p></li><li><p><strong>磁盘阵列</strong></p><p><strong>PAID（独立冗余磁盘阵列）是指将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。</strong></p><p>RAID0: 无冗余和无校验的磁盘阵列</p><p>RAID1: 镜像磁盘阵列</p><p>RAID2: 采用纠错的海明码的磁盘阵列</p><p>RAID3: 位交叉奇偶校验的磁盘阵列</p><p>RAID4: 块交叉奇偶校验的磁盘阵列</p><p>RAID5: 无独立校验的奇偶校验磁盘阵列</p><p>总之，RAID通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像备份，提高安全可靠性；通过数据校验，提供容错能力。</p></li></ol><h5 id="2-固态硬盘"><a href="#2-固态硬盘" class="headerlink" title="2. 固态硬盘"></a>2. 固态硬盘</h5><p>固态硬盘是一种基于闪存技术的存储器。它与U盘并没有本质上的区别，只是容量更大、存储性能更好。</p><p>固态硬盘的特点：基于闪存的存储技术、随机写很慢、随机读写性能明显高于磁盘、容易磨损。</p><h4 id="3-5-高速缓冲存储器"><a href="#3-5-高速缓冲存储器" class="headerlink" title="3.5 高速缓冲存储器"></a>3.5 高速缓冲存储器</h4><h5 id="1-程序访问的局部性原理"><a href="#1-程序访问的局部性原理" class="headerlink" title="1. 程序访问的局部性原理"></a>1. 程序访问的局部性原理</h5><p><img src="/images/计组第3章-存储系统/image-20220724180300224.png" alt="" style="zoom: 67%;"></p><h5 id="2-Cache的基本工作原理"><a href="#2-Cache的基本工作原理" class="headerlink" title="2. Cache的基本工作原理"></a>2. Cache的基本工作原理</h5><p>Cache位于存储器层次结构的顶层，通常由SRAM构成。为便于Cache和主存交换信息，Cache和主存通常被划分为大小相等的块，Cache块又称Cache行，每块由若干字节组成，块的长度称为块长（Cache行长）。</p><p><img src="/images/计组第3章-存储系统/image-20220724181021396.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220724181049649.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220724181150167.png" alt=""></p><h5 id="3-Cache和主存的映射方式"><a href="#3-Cache和主存的映射方式" class="headerlink" title="3. Cache和主存的映射方式"></a>3. Cache和主存的映射方式</h5><p><img src="/images/计组第3章-存储系统/image-20220724181329933.png" alt=""></p><ol><li><p><strong>全相联映射</strong></p><p><strong>主存中的每一块可以装入Cache中的任何位置</strong>，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有Cache行的标记进行比较。<strong>标记 = 主存块地址</strong>，主存地址 = 主存块地址（标记） + 块内地址。</p><p>优点：比较灵活，冲突率低，空间利用率高，命中率高；</p><p>缺点：标记长，标记的比较速度慢，实现成本高通常采用价格昂贵的相联存储器。</p><p><img src="/images/计组第3章-存储系统/image-20220724182111571.png" alt=""></p></li><li><p><strong>直接映射</strong></p><p>主存中的每一块只能装入Cache块中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将被无条件替换出去（<strong>无需使用替换算法</strong>）。</p><p>直接映射规则：<strong>Cache行号 = 主存块号 % Cache总行数</strong></p><p>主存地址结构：<strong>主存块地址 = 标记 + Cache行号</strong>，主存地址 = 标记 + Cache行号 + 块内地址。</p><p>假设Cache共有$2^{c}$行，主存有$2^{m}$块，则每个Cache行会对应$2^{m-c}$块，故需要设置一个长为m-c的标记，以确定该Cache行的内容来自$2^{m-c}$块中的哪一块。而主存块号的低c位正好是它要装入的Cache行号。</p><p>直接映射实现简单，但不够灵活，块冲突概率最高，空间利用率最低。</p><p><img src="/images/计组第3章-存储系统/image-20220724190305533.png" alt=""></p></li><li><p><strong>组相联映射</strong></p><p>将Cache分成Q个大小相等的组，每个主存块可装入固定组中的任意一行，即组间采用直接映射、而组内采用全相联映射的方式。它是对全相联映射和直接映射的一种折中，当Q=1时变为全相联映射，当Q=Cache行数时变为直接映射。假设每组有r个Cache行，则称之为r路组相联。</p><p>组相联的映射关系为：<strong>Cache组号 = 主存块号 % Cache组数Q</strong></p><p>选定适当的分组数量，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。</p><p>组相联映射的主存地址结构为：<strong>主存块地址 = 标记 + 组号</strong>，主存地址 = 标记 + 组号 + 块内地址。</p><p>组间作区分，组内不作区分，给定一个主存块，根据主存块号%Cache组数Q确定组号，然后映射至该组内空闲的Cache块，若Cache块均已装满，则根据替换算法进行替换。</p><p><img src="/images/计组第3章-存储系统/image-20220724192557766.png" alt=""></p></li></ol><h5 id="4-Cache中主存块的替换算法"><a href="#4-Cache中主存块的替换算法" class="headerlink" title="4. Cache中主存块的替换算法"></a>4. Cache中主存块的替换算法</h5><p>在采用全相联映射或组相联映射方式时，从主存向Cache传送一个新块，当Cache或Cache组中的空间已被占满时，就需要使用替换算法置换Cache行。而采用直接映射方式时，由于新主存块的Cache行位置是固定的，所以直接将该位置替换即可，无需考虑替换算法。</p><p>常见的替换算法有：随机（RAND）替换算法；先进先出法（First in First out）;近期最少使用法（Least recently Used）;最不经常使用法（Least Frequently Used）。</p><ol><li><p><strong>随机算法（RAND）</strong>：随机替换。没有依据程序的局部性原理，所以可能会降低命中率。</p></li><li><p><strong>先进先出算法（FIFO）</strong>：选择最早调入的行进行替换。最早调入的内容也可能是目前经常要用的，所以也没有依据程序的局部性原理。</p></li><li><p><strong>近期最少使用算法（LRU）</strong>：依据<strong>程序访问的局部性原理</strong>，选择近期长久未访问过的Cache行作为替换的行，平均命中率比FIFO要高，是堆栈类算法。LRU算法对每个Cache行设置一个计数器，记录未访问的时间长短，命中某一行时，该行计数值清零，其余行计数值加一，计数值越大说明，说明近期使用到的概率越低。</p><p>当集中访问的存储区超过Cache组的大小时，命中率可能变得很低，这种现象称为<strong>抖动</strong>。</p></li><li><p><strong>最不经常使用算法（LFU）</strong>：将一段时间内被访问次数最少的Cache行换出。同样设置一个计数器，记录每一行被访问的次数，需要替换时，将计数值最小的行换出。LFU算法看似合理其实也有一定的缺陷，因为总的使用次数最少并不意味着近期使用的次数也最少，根据程序访问的局部性原理，我们应该以近期的使用次数作为衡量标准。</p></li></ol><h5 id="5-Cache写策略"><a href="#5-Cache写策略" class="headerlink" title="5. Cache写策略"></a>5. Cache写策略</h5><p>因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就需选用写操作策略使Cache内容与主存内容保持一致。此时分两种情况。</p><p>对于<strong>Cache写命中（write hit）</strong>，有两种处理方法：</p><ol><li><p><strong>全写法（写直通法、write-through）</strong>。当CPU对Cache写命中时，必须把数据同时写入Cache和主存当某一块需要替换时，因为已经写入主存，所以直接替换即可。这种方法实现简单，主存与Cache即时同步，能随时保持主存数据的正确性，缺点是增加了访存次数，降低了Cache的效率。</p><p>为减少全写法直接写入主存的时间损耗，在Cache和主存之间添加了一个写缓冲（Write Buffer）。CPU同时将数据写入Cache和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，可以解决速度不匹配的问题，但若出现频繁写时，会使写缓冲饱和溢出。</p></li><li><p><strong>回写法（write-back）</strong>。当CPU对Cache写命中时，只把数据写入Cache中，而不立即写入主存，只有当此块被换出时才写回主存。这种方法减少了访存次数，但存在数据不一致的隐患。为了减少写回主存的开销，每个Cache行设置一个修改位（脏位）。若修改位为1，则说明对应Cache行中的块被修改过，替换时需要写回主存；若修改位为0，则说明数据未被修改过，替换时无需写回主存。</p></li></ol><p>对于<strong>Cache写不命中</strong>，也有两种处理方法：</p><ol><li><p><strong>写分配法（write-allocate）</strong>。加载主存中的块到Cache中，然后更新这个块。它试图利用程序的空间局部性原理，即在某个存储单元被访问时，它附近的存储单元也很可能即将被访问（因为程序往往是顺序存储的，一段程序的指令和数据通常集中存储在相邻的一片存储区域中），因此可以先将该存储单元所在的块调入Cache中，如果命中，则CPU无需再进行访存，直接与Cache交换数据，程序的执行速度大大提高。</p><p>但缺点是每次不命中都需要从主存中读取一块，如果CPU不需要再使用该块中的内容，则一方面浪费了Cache的空间，另一方面凭白多消耗了一次主存块调入Cache的时间。</p></li><li><p><strong>非写分配法（not-write-allocate）</strong>。只写入主存，不进行调块。虽然不会提高速度但至少也不会减慢速度。</p></li></ol><p><strong>非写分配法通常与全写法合用，写分配法通常与回写法合用。</strong>即写命中时如果同时将数据写入主存和Cache，则写不命中时，只写入主存，不进行调块。写命中时，如果只写入Cache，则写不命中时，进行调块，至Cache块被替换时再根据修改位写回主存。</p><p>随着新技术的发展（如指令预取），需要将指令Cache和数据Cache分离，分离的主要目的是减少指令流水线的资源冲突。</p><h4 id="3-6-虚拟存储器"><a href="#3-6-虚拟存储器" class="headerlink" title="3.6 虚拟存储器"></a>3.6 虚拟存储器</h4><h5 id="1-虚拟存储器的基本概念"><a href="#1-虚拟存储器的基本概念" class="headerlink" title="1. 虚拟存储器的基本概念"></a>1. 虚拟存储器的基本概念</h5><p><img src="/images/计组第3章-存储系统/image-20220724213434258.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220724213522820.png" alt=""></p><h5 id="2-页式虚拟存储器"><a href="#2-页式虚拟存储器" class="headerlink" title="2. 页式虚拟存储器"></a>2. 页式虚拟存储器</h5><p><img src="/images/计组第3章-存储系统/image-20220724213612239.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220724213650698.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220724213749639.png" alt=""></p><h5 id="3-段式虚拟存储器"><a href="#3-段式虚拟存储器" class="headerlink" title="3. 段式虚拟存储器"></a>3. 段式虚拟存储器</h5><p><img src="/images/计组第3章-存储系统/image-20220724214839881.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220724214917023.png" alt=""></p><h5 id="4-段页式虚拟存储器"><a href="#4-段页式虚拟存储器" class="headerlink" title="4. 段页式虚拟存储器"></a>4. 段页式虚拟存储器</h5><p><img src="/images/计组第3章-存储系统/image-20220724214958091.png" alt=""></p><p><img src="/images/计组第3章-存储系统/image-20220724215026995.png" alt=""></p><h5 id="5-虚拟存储器与Cache的比较"><a href="#5-虚拟存储器与Cache的比较" class="headerlink" title="5. 虚拟存储器与Cache的比较"></a>5. 虚拟存储器与Cache的比较</h5><p>相同之处：</p><ol><li>最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度；</li><li>都是把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大；</li><li>都有地址的映射、替换算法、更新策略等问题；</li><li>依据程序的局部性原理，应用“快速缓存”的思想，将活跃的数据放在相对高速的部件中。</li></ol><p>不同之处：</p><ol><li>Cache主要解决系统速度，而虚拟存储器则是解决主存容量；</li><li>Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器则是由操作系统和硬件共同实现，，是逻辑上的存储器，对系统程序员不透明，但是对应用程序员透明；</li><li>对于不命中性能影响，因为CPU的速度约为Cache的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能影响更大；</li><li>CPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组第2章-数据的表示和运算</title>
      <link href="/2022/07/27/ji-zu-di-2-zhang-shu-ju-de-biao-shi-he-yun-suan/"/>
      <url>/2022/07/27/ji-zu-di-2-zhang-shu-ju-de-biao-shi-he-yun-suan/</url>
      
        <content type="html"><![CDATA[<h3 id="第二章-数据的表示和运算"><a href="#第二章-数据的表示和运算" class="headerlink" title="第二章 数据的表示和运算"></a>第二章 数据的表示和运算</h3><h4 id="考纲内容"><a href="#考纲内容" class="headerlink" title="考纲内容"></a>考纲内容</h4><blockquote><p>（一）数制与编码</p><p>​        进位计数制及其相互转换；定点数的编码表示</p><p>（二）运算方法和运算电路</p><p>​        基本运算部件：加法器，算术逻辑单元（ALU）</p><p>​        加/减运算：补码加/减运算器，标志位的生成</p><p>​        乘/除运算：乘/除运算的基本原理，乘法运算和除法电路的基本结构</p><p>（三）整数的表示和运算</p><p>​        无符号整数的表示和运算；带符号整数的表示和运算</p><p>（四）浮点数的表示和运算</p><p>浮点数的表示：IEEE754标准；浮点数的加/减运算</p></blockquote><h4 id="一、数制与编码"><a href="#一、数制与编码" class="headerlink" title="一、数制与编码"></a>一、数制与编码</h4><h5 id="1-进位计数制及其相互转换"><a href="#1-进位计数制及其相互转换" class="headerlink" title="1.进位计数制及其相互转换"></a>1.进位计数制及其相互转换</h5><p>在进位计数法中，一个数由若干个<strong>数位</strong>组成，每个数位都有其<strong>基数</strong>与<strong>位权</strong>。</p><p>这个数的十进制值由各个数位上的基数按位权展开并相加得到，称为<strong>按权展开相加法</strong>。</p><h6 id="1-二进制与八进制、十六进制的转换"><a href="#1-二进制与八进制、十六进制的转换" class="headerlink" title="(1) 二进制与八进制、十六进制的转换"></a>(1) 二进制与八进制、十六进制的转换</h6><p>一个二进制数（即一个二进制位）可以表示的数只有0和1两个，而一个八进制数可以表示的数有0~7共八个，刚好可以由3个二进制位来完全表示（<code>2**3=8</code>），故1个八进制位可以转换为3个二进制位，同理，1个十六进制位可以转换为4个二进制位。</p><p>而十六进制和八进制的相互转换可以通过二进制作为过渡。</p><h6 id="2-任意进制数转换为十进制数"><a href="#2-任意进制数转换为十进制数" class="headerlink" title="(2) 任意进制数转换为十进制数"></a>(2) 任意进制数转换为十进制数</h6><p>将任意进制数各个数位上的基数与它们的权值相乘，再把乘积累加，即可得到其十进制值，即按权展开相加法。</p><h6 id="3-十进制数转换为任意进制数"><a href="#3-十进制数转换为任意进制数" class="headerlink" title="(3) 十进制数转换为任意进制数"></a>(3) 十进制数转换为任意进制数</h6><p>整数部分：除基取余法。（自下向上）</p><p>小数部分：乘基取整法。（自上向下）</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220708135843597.png" alt=""></p><h5 id="2-定点数的编码表示"><a href="#2-定点数的编码表示" class="headerlink" title="2.定点数的编码表示"></a>2.定点数的编码表示</h5><p><strong>真值和机器数：以(+)(-)号来表示正负的数称为真值，以0和1来表示正负的称为机器数。</strong></p><p>BCD码：二进制编码的十进制数，有<code>2**4-10=6</code>位冗余，常见的BCD码有8421码。</p><p>1.机器数的定点表示</p><p>定点数与浮点数相对，包含定点小数和定点整数，定点小数即纯小数，范围在（-1,1）内，其整数部分为0，定点整数即纯整数，其小数部分为0。</p><p>定点小数的小数点位置在符号位之后，有效数值部分最高位之前；定点整数小数点在有效数值部分最低位之后。</p><p>定点数的编码表示主要有四种：原码、反码、补码、移码。</p><h6 id="1-原码-Sign-Magnitude"><a href="#1-原码-Sign-Magnitude" class="headerlink" title="(1) 原码(Sign-Magnitude)"></a>(1) 原码(Sign-Magnitude)</h6><p><strong>用机器数的最高位表示数的符号，0代替正号，1代替负号，其余各位不变，即得真值的原码。</strong></p><p>当真值为正数时，最高位为0，故<code>真值x = 原码[x]</code></p><p>当真值为负数时，其最高位为1，记真值为x(x&lt;0,包含负号)</p><blockquote><p>如果是整数，权值为<code>2**n</code>,n为整数位数，故<code>[x]原 = 2**n + |x|</code></p><p>如果是小数，权值为<code>2**0 = 1</code>,设小数位数为n，则<code>[x]原 = 1 + |x|</code></p></blockquote><p><strong>原码最高有效位是符号位，没有权值，仅用来确定剩下的位应该取正权还是负权</strong>：</p><script type="math/tex; mode=display">B2S_{w}(\vec{x})=(-1)^{x_{w-1}}(\sum_{i=0}^{w-2}x_{i}2^{i})</script><p>原码表示范围：$SMin_{w}=[1,111\cdot\cdot\cdot1]=-2^{w-1}+1$,$SMax_{w}=[0,111\cdot\cdot\cdot1]=2^{w-1}-1$,关于原点对称。</p><h6 id="2-补码-Two’s-complement"><a href="#2-补码-Two’s-complement" class="headerlink" title="(2) 补码(Two’s-complement)"></a>(2) 补码(Two’s-complement)</h6><p><strong>补码的最高位为负权</strong>，其余各位为正权，最高位为0代表正数，最高位为1代表负数。</p><p>对于向量</p><script type="math/tex; mode=display">\vec{x}=[x_{w-1},x_{w-2},\cdot\cdot\cdot,x_{0}]:</script><script type="math/tex; mode=display">B2T_{w}(\vec{x})=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}</script><p>$B2T_{w}$（Binary to Two’s-complement，二进制转化为二进制的补码：将真值（二进制向量）的最高位权重取负，再与其余各数位按权展开相加，即可得到其补码的十进制值，根据除2取余法即可转换为二进制形式的补码，该补码位数不足8位时，正数最高位补0，负数最高位补1，其余位补0）。<strong>补码的最高有效位 $x_{w-1}$也称为符号位，它的权重为$-2^{w-1}$。</strong></p><p>当真值x为正数时，$x_{w-1}=0$,故$[x]补=\sum_{i=0}^{w-2}x_{i}2^{i}=真值x$;</p><p>当真值x为负数时，$x_{w-1}=1$, $B2T_{w}(\vec{x})=-2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}$,</p><p>如果是整数，真值的绝对值$|x|=[x]补+x_{w-1}2^{w}$，即相差了两个$x_{w-1}2^{w-1}$。</p><p>补码所能表示的范围：$TMin_{w}=[1,0,0,0,\cdot\cdot\cdot,0]=-2^{w-1}$,$TMax_{w}=[0,1,1,1,\cdot\cdot\cdot,1]=2^{w-1}-1$。</p><p>$TMax_{w}=-TMin_{w}-1$,补码的范围是不对称的，$TMin_{w}$没有与之对应的正数。</p><h6 id="3-反码-One’s-Complement"><a href="#3-反码-One’s-Complement" class="headerlink" title="(3)  反码(One’s Complement)"></a>(3)  反码(One’s Complement)</h6><p>除了最高有效位的权是$-(2^{w-1}-1)$而不是$-2^{w-1}$,它和补码是一样的：</p><script type="math/tex; mode=display">B2O_{w}(\vec{x})=-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_{i}2^{i}</script><p>由原码求反码：符号位不变，尾数取反；</p><p>由反码求补码：末位+1；</p><p><strong>故由原码求补码：符号位不变，尾数取反，末位加一。</strong></p><h6 id="4-移码"><a href="#4-移码" class="headerlink" title="(4)  移码"></a>(4)  移码</h6><p><strong>移码和补码：符号位相反，数值位相同。</strong></p><p>移码全0时，对应真值的最小值$-2^{n}$,移码全1时，对应真值的最大值$2^{n}-1$。</p><p>移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小。</p><h6 id="5-原码、反码、补码、移码总结："><a href="#5-原码、反码、补码、移码总结：" class="headerlink" title="(5) 原码、反码、补码、移码总结："></a>(5) 原码、反码、补码、移码总结：</h6><ul><li>原码、补码、反码的符号位相同，正数的机器数相同；</li><li>原码、反码的表示在数轴上对称，二者都存在+0和-0两个零；</li><li>补码、移码不对称，0的表示唯一，它们比原码、反码多出一个位置来表示一个数；</li><li><strong>将真值的(+)(-)负号用0和1来表示即得真值的原码；原码符号位不变、尾数取反即得反码；反码末位+1即得补码；补码符号位取反即得移码；</strong></li><li><strong>补码和真值的相互转换：连同符号位一起取反，末位加1。</strong></li><li><strong>[x]补转换为[-x]补：各位取反，末位+1。</strong></li></ul><h4 id="二、运算方法和运算电路"><a href="#二、运算方法和运算电路" class="headerlink" title="二、运算方法和运算电路"></a>二、运算方法和运算电路</h4><h5 id="1-基本运算部件"><a href="#1-基本运算部件" class="headerlink" title="1.基本运算部件"></a>1.基本运算部件</h5><p>在计算机中，运算器是由算术逻辑单元ALU、移位器、状态寄存器、和通用寄存器等组成。运算器的基本功能包括加、减、乘、除四则运算，与、或、非、异或等逻辑运算以及移位、求补等操作。ALU的核心部件是加法器。</p><h6 id="1-一位全加器"><a href="#1-一位全加器" class="headerlink" title="(1) 一位全加器"></a>(1) 一位全加器</h6><p><img src="/images/计组第2章-数据的表示和运算/image-20220706171044267.png" alt="" style="zoom:50%;"></p><p>全加器（FA）是最基本的加法单元，有加数A加数B与低位传来的进位$C_{i-1}$共三个输入，有本位和$S_{i}$和向高位的进位$C_{i}$共两个输出。全加器的逻辑表达式如下：</p><p>和表达式：$S_{i}=A_{i}⊕B_{i}⊕C_{i-1}$（有奇数个1时，$S_{i}=1$;否则$S_{i}=0$）</p><p>进位表达式：$C_{i}=A_{i}B_{i}+(A_{i}⊕B_{i})C_{i-1}$</p><h6 id="2-串行进位加法器"><a href="#2-串行进位加法器" class="headerlink" title="(2) 串行进位加法器"></a>(2) 串行进位加法器</h6><p>把n个加法器相连可以得到n位加法器，称为串行进位加法器。串行进位加法器是实现了两个n位二进制数$A=A_{n}A_{n-1}\cdot\cdot\cdot A_{1}$和$B=B_{n}B_{n-1}\cdot\cdot\cdot B_{1}$逐位相加的功能。</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706172746396.png" alt="" style="zoom:50%;"></p><p>得到的和为$S=S_{n}S_{n-1}\cdot\cdot\cdot S_{1}$,进位输出为$C_{n}$.</p><p>由于加法器位数有限，如果超过了最高位数，高位自动丢失，所以实际是模$2^{n}$的加法运算。</p><p>在串行进位加法器中，低位运算所产生进位所需的时间将影响高位运算的时间。串行进位加法器的最长运算时间主要是由进位信号的传递时间决定的，位数越多延迟时间越长，而全加器本身的求和延迟只是次要因素，因此加快进位产生和提高传递的速度是提升性能的关键。</p><h6 id="3-并行进位加法器"><a href="#3-并行进位加法器" class="headerlink" title="(3) 并行进位加法器"></a>(3) 并行进位加法器</h6><p><strong>令$G_{i}=A_{i}B_{i}$,称为进位产生函数，即进位信号；$P_{i}=A_{i}⊕B_{i}$,称为进位传递函数，即进位传递信号。</strong></p><p>$C_{i}$仅与$A_{i}$、$B_{i}$和最低进位$C_{0}$有关，相互间的进位没有依赖关系。只要$A_{1}$~$A_{n}$ ,$B_{1}$~$B_{n}$和$C_{0}$同时到达，就可以几乎同时形成$C_{1}$ ~ $C_{4}$,并且同时生成各位的和。</p><p>实现上述逻辑的电路称为先行进位部件，简称CLA部件。通过这种进位方式实现的加法器称为全先行进位加法器。</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706182924797.png" alt="" style="zoom: 50%;"></p><p>这种进位方式是快速的，与位数无关。但随着加法器位数的增加，$C_{i}$的逻辑表达式会变得越来越长，这会使电路结构越来越复杂，所以可以将加法器部件先分组，采取组内并行进位，组间再并行进位的方式，可以控制每个部分的复杂性，同时也进一步提高了运算速度。</p><h6 id="4-带标志加法器"><a href="#4-带标志加法器" class="headerlink" title="(4) 带标志加法器"></a>(4) 带标志加法器</h6><p><img src="/images/计组第2章-数据的表示和运算/image-20220706184853883.png" alt="" style="zoom: 80%;"></p><p>在无符号加法器的基础上添加了溢出标志OF，符号标志SF，零标志ZF，进位/借位标志CF。值得注意的是，为了加快加法运算的速度，实际电路一定使用多级先行进位方式。</p><h6 id="5-算术逻辑单元ALU"><a href="#5-算术逻辑单元ALU" class="headerlink" title="(5) 算术逻辑单元ALU"></a>(5) 算术逻辑单元ALU</h6><p>ALU的核心是带标志加法器，同时也能执行与或非等逻辑运算。ALU基本结构如图所示，<code>ALUop</code>是操作控制端，用来决定ALU所执行的处理功能，<code>ALUop</code>的位数决定了操作的种类数量。</p><p>MUX是多路选择开关，它从多个输入信号中选择一个送到输出端。</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706190140139.png" alt=""></p><h5 id="2-定点数的移位运算"><a href="#2-定点数的移位运算" class="headerlink" title="2.定点数的移位运算"></a>2.定点数的移位运算</h5><h6 id="1-算术移位"><a href="#1-算术移位" class="headerlink" title="(1) 算术移位"></a>(1) 算术移位</h6><p><strong>算术移位：符号位不变、数码位置变化</strong>。</p><p>算术移位的对象是有符号数，在移位过程中符号位保持不变。</p><p>对于正数，由于<code>原码 = 反码 = 补码 = 真值</code>，因此移位后出现的空位全部补0。对于负数，因为原码、反码、补码的表示形式不同，因此当机器数移位时，对其空位的添补规则也不同。</p><blockquote><p>注意：不论是正数还是负数，移位后其符号位均不变，且移位后都相当于对真值补0。</p></blockquote><p>负数的算术移位添补规则：</p><div class="table-container"><table><thead><tr><th></th><th>码制</th><th style="text-align:left">添补代码</th></tr></thead><tbody><tr><td>正数</td><td>原码、反码、补码</td><td style="text-align:left">0</td></tr><tr><td></td><td>原码</td><td style="text-align:left">0</td></tr><tr><td>负数</td><td>反码</td><td style="text-align:left">左移添0，右移添1</td></tr><tr><td></td><td>补码</td><td style="text-align:left">1</td></tr></tbody></table></div><h6 id="2-逻辑移位"><a href="#2-逻辑移位" class="headerlink" title="(2) 逻辑移位"></a>(2) 逻辑移位</h6><p><strong>逻辑移位：数码位置变化。</strong></p><p>逻辑移位时将操作数视为无符号数。</p><p>移位规则：逻辑左移时，高位移丢，低位添0；逻辑右移时，低位移丢，高位添0。</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706191610089.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706191752334.png" alt=""></p><h6 id="3-循环移位"><a href="#3-循环移位" class="headerlink" title="(3) 循环移位"></a>(3) 循环移位</h6><p>循环移位分为带进位标志位CF的循环移位和不带进位标志位的循环移位。循环移位的主要特点是，移出的数位又被移入数据中。循环移位适合于将数据的低字节数据和高字节数据互换。</p><h5 id="3-定点数的加减运算"><a href="#3-定点数的加减运算" class="headerlink" title="3.定点数的加减运算"></a>3.定点数的加减运算</h5><h6 id="1-补码的加减法运算"><a href="#1-补码的加减法运算" class="headerlink" title="(1) 补码的加减法运算"></a>(1) 补码的加减法运算</h6><p>定点数一般用补码表示，符号位参与运算。</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706195529993.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706195624577.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706195651109.png" alt=""></p><h6 id="2-补码加减运算电路"><a href="#2-补码加减运算电路" class="headerlink" title="(2) 补码加减运算电路"></a>(2) 补码加减运算电路</h6><p><img src="/images/计组第2章-数据的表示和运算/image-20220706195752856.png" alt=""></p><h6 id="3-溢出判断方法"><a href="#3-溢出判断方法" class="headerlink" title="(3) 溢出判断方法"></a>(3) 溢出判断方法</h6><p><img src="/images/计组第2章-数据的表示和运算/image-20220706200603460.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706200618745.png" alt=""></p><p>逻辑一（根据符号判断）：无论是加法还是减法，只要<strong>参加操作的两个数符号相同，结果又与原操作数符号不同</strong>，则表示结果溢出。</p><p>根据溢出逻辑表达式，当溢出逻辑V=0时，表示无溢出；当溢出逻辑V=1时，表示有溢出。</p><p>逻辑二（根据进位判断）：若符号位的进位$C_{f}$与最高数位的进位C相同，$V=C_{f}⊕C=0$表示无溢出，<strong>若符号位的进位与最高位的进位不一致，V=1表示有溢出。</strong></p><p>逻辑三（根据双符号位判断）：采用双符号位时，若结果的两个符号位相同，$V=S_{f1}⊕S_{f2}=0$,表示无溢出，V=1表示溢出。<strong>01表示正溢，10表示负溢。</strong></p><h6 id="4-原码的加减法运算"><a href="#4-原码的加减法运算" class="headerlink" title="(4) 原码的加减法运算"></a>(4) 原码的加减法运算</h6><p><img src="/images/计组第2章-数据的表示和运算/image-20220706202418827.png" alt=""></p><h5 id="4-定点数的乘除运算"><a href="#4-定点数的乘除运算" class="headerlink" title="4.定点数的乘除运算"></a>4.定点数的乘除运算</h5><h6 id="1-◓原码一位乘法"><a href="#1-◓原码一位乘法" class="headerlink" title="(1) ◓原码一位乘法"></a>(1) ◓原码一位乘法</h6><p><img src="/images/计组第2章-数据的表示和运算/image-20220706205641762.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706205701414.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706205722544.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706205738465.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706205754110.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220706205806670.png" alt=""></p><h6 id="2-无符号数乘法运算电路"><a href="#2-无符号数乘法运算电路" class="headerlink" title="(2) 无符号数乘法运算电路"></a>(2) 无符号数乘法运算电路</h6><p><img src="/images/计组第2章-数据的表示和运算/image-20220707090213305.png" alt=""></p><h6 id="3-补码一位乘法"><a href="#3-补码一位乘法" class="headerlink" title="(3) 补码一位乘法"></a>(3) 补码一位乘法</h6><p>补码一位乘法是有符号数的乘法，采用相加和相减操作计算补码数据的乘积。</p><p>设$[X]补=x_{s}\cdot x_{1}x_{2}\cdot\cdot\cdot x_{n}$,$[Y]补=y_{s}\cdot y_{2}y_{2}\cdot\cdot\cdot y_{n}$,则运算规则如下：</p><ul><li>符号位参与运算，运算的数均以补码表示。</li><li>被乘数一般取双符号位参与运算，部分积取双符号位，初始值为0，乘数取单符号位。</li><li>乘数末位增设附加位$y_{n+1}$,初始值为0。</li><li>根据$y_{n}y_{n+1}$的取值来确定操作，见下图。</li></ul><p><img src="/images/计组第2章-数据的表示和运算/image-20220707090920563.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220707090936191.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220707090947715.png" alt=""></p><h6 id="4-符号扩展"><a href="#4-符号扩展" class="headerlink" title="(4) 符号扩展"></a>(4) 符号扩展</h6><ol><li><strong>无符号数使用零扩展</strong></li><li><strong>补码数使用符号扩展</strong></li></ol><p><img src="/images/计组第2章-数据的表示和运算/image-20220707093540297.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220707093601666.png" alt=""></p><h6 id="5-原码除法运算"><a href="#5-原码除法运算" class="headerlink" title="(5) 原码除法运算"></a>(5) 原码除法运算</h6><h6 id="6-◒补码不恢复余数除法"><a href="#6-◒补码不恢复余数除法" class="headerlink" title="(6) ◒补码不恢复余数除法"></a>(6) ◒补码不恢复余数除法</h6><p>补码一位除法的特点是，符号位与数值位一起参与运算，商符自然形成。</p><p>除法第一步根据被除数和除数的符号决定做加法还是减法；上商的原则根据余数和被除数的符号位共同决定，同号上商”1”，异号上商”0”；最后一步商恒置”1”。</p><p>加减法的交替规则如下：</p><ol><li>符号位参与运算，除数、被除数以及商和余数均用补码表示。</li><li>若被除数与除数同号，则被除数减去除数；若被除数与除数异号，则被除数加上除数。</li><li><strong>若余数与除数同号，则商上”1”，余数左移一位减去除数；若异号则商上”0”，余数左移一位加上除数。</strong></li><li>重复执行第3步n次。</li><li>若对商的精度没有要求，则一般采用”末位恒置1“法。</li></ol><p><img src="/images/计组第2章-数据的表示和运算/image-20220707095952702.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220707100006747.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220707100018482.png" alt=""></p><h6 id="7-除法运算电路"><a href="#7-除法运算电路" class="headerlink" title="(7) 除法运算电路"></a>(7) 除法运算电路</h6><p><img src="/images/计组第2章-数据的表示和运算/image-20220707105924745.png" alt=""></p><h5 id="5-C语言整数类型转换"><a href="#5-C语言整数类型转换" class="headerlink" title="5.C语言整数类型转换"></a>5.C语言整数类型转换</h5><h6 id="1-有符号数和无符号数的转换"><a href="#1-有符号数和无符号数的转换" class="headerlink" title="(1) 有符号数和无符号数的转换"></a>(1) 有符号数和无符号数的转换</h6><ol><li>强制类型转换的原理</li></ol><p>C语言允许在不同的数据类型之间进行强制类型转换。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int main(){    short x=-4321;    unsigned short y=(unsigned short)x;    printf("x=%d, y=%u\n",x,y);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在采用补码的机器上，上述代码会输出如下结果：</p><pre class="line-numbers language-none"><code class="language-none">x=-4321,y=61215<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这两个值看似没有任何关系，不过将它们转换为二进制表示时，我们就会发现其中的规律：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">x=11111111111111111110111100011111y=                1110111100011111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以发现x和y的二进制表示是一致的，只不过x进行了符号扩展。</p><p>因此，<strong>强制类型转换的结果保持位值不变，仅改变了解释这些位值的方式。</strong></p><ol><li>有符号数与无符号数的相互转换方式</li></ol><p>【2016统考真题】有如下C语言程序段：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">short si = -32767;unsigned short usi = si;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行上述两条语句后，<code>usi</code>的值为（  ）。</p><pre class="line-numbers language-none"><code class="language-none">A. -32767B. 32767C. 32768D. 32769<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【2019统考真题】考虑以下C语言代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">unsigned short usi = 65535;short si = usi;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行上述程序段后，<code>si</code>的值是（  ）。</p><pre class="line-numbers language-none"><code class="language-none">A. -1B. -32767C. -32768D. -65535<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【分析】：这两个题都是对无符号数与有符号数的相互转换的考察，我们要熟悉无符号数与有符号数的表示范围与转换规则。</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220707213217903.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220707213230541.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220707213451081.png" alt=""></p><h6 id="2-不同字长整数之间的转换"><a href="#2-不同字长整数之间的转换" class="headerlink" title="(2) 不同字长整数之间的转换"></a>(2) 不同字长整数之间的转换</h6><ol><li>当大字长变量向小字长变量强制类型转换时，系统把多余的高位部分直接<strong>截断</strong>，低位直接赋值，因此也是一种保持位值的方法；</li><li>短字长整数到长字长整数的转换时，不仅要使相应的位值相等，还要对高位部分进行扩展。如果原数字是无符号整数，则进行<strong>零扩展</strong>，否则进行<strong>符号扩展</strong>。</li></ol><h5 id="6-数据的存储和排列"><a href="#6-数据的存储和排列" class="headerlink" title="6.数据的存储和排列"></a>6.数据的存储和排列</h5><h6 id="1-大端法和小端法"><a href="#1-大端法和小端法" class="headerlink" title="(1) 大端法和小端法"></a>(1) 大端法和小端法</h6><p><img src="/images/计组第2章-数据的表示和运算/image-20220707135807966.png" alt=""> </p><h6 id="2-数据按边界对齐存储"><a href="#2-数据按边界对齐存储" class="headerlink" title="(2) 数据按边界对齐存储"></a>(2) 数据按边界对齐存储</h6><p>当告诉我们按字节编址时，即每个字节都有其地址；当告诉我们机器字长为32位时，即一个机器字包含4个字节，注意数据存储是否按机器字的边界对齐。</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220707135940966.png" alt=""></p><p>数据以按边界对齐方式存放可以一次访存取出，所存储的数据不能恰好按边界对齐时，可以填补空白字节，使之按边界对齐，这样虽然浪费了一些存储空间，但可以提高取指令和取数的速度。</p><h5 id="7-浮点数的表示与运算"><a href="#7-浮点数的表示与运算" class="headerlink" title="7.浮点数的表示与运算"></a>7.浮点数的表示与运算</h5><p><img src="/images/计组第2章-数据的表示和运算/image-20220708175817299.png" alt=""></p><p><img src="/images/计组第2章-数据的表示和运算/image-20220708175911661.png" alt=""></p><h6 id="1-浮点数的表示格式"><a href="#1-浮点数的表示格式" class="headerlink" title="(1) 浮点数的表示格式"></a>(1) 浮点数的表示格式</h6><p>通常，浮点数表示为</p><script type="math/tex; mode=display">N=(-1)^{S}×M×R^{E}</script><p>其中，S为数符，取值0或1，用来决定浮点数的符号；</p><p>M是尾数，为二进制定点小数，一般用定点原码小数表示，尾数的位数反映浮点数的精度；</p><p>R为基数，二进制基数R=2；</p><p>E为阶码，即指数，用移码表示。阶码的值反映浮点数的小数点的实际位置，阶码的位数反映浮点数的表示范围。</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220708093014957.png" alt=""></p><h6 id="2-浮点数的规格化"><a href="#2-浮点数的规格化" class="headerlink" title="(2) 浮点数的规格化"></a>(2) 浮点数的规格化</h6><p>规格化：约定尾数M的值域，使浮点数的表示代码是唯一的、确定的。</p><p>所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非零的浮点数在尾数的最高数位上保证是一个有效值（十进制），即阶码的位模式既不全为0，也不全为1。</p><p>当阶码的位模式全为0时，说明尾数M过小，尾数的最高数位不是有效位，应该对尾数M进行左规，尾数每左移一位，阶码减1（基数为2时）；</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220708102345481.png" alt=""></p><p>尾数是纯小数，M＜1，当运算结果的尾数的小数位进到小数点前面时，需要进行右规，将尾数右移一位阶码加1（基数为2时），需要右规时，只需进行一次，左规可能要进行多次。</p><p>当阶码全为1时，表明该数是一个特殊值，可能为$+∞$、$-∞$或<code>NaN</code>(Not a Number)。</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220708093703792.png" alt=""></p><h6 id="3-IEEE754标准"><a href="#3-IEEE754标准" class="headerlink" title="(3) IEEE754标准"></a>(3) IEEE754标准</h6><p>按照IEEE754标准，常用的浮点数格式如下：</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220708102215311.png" alt=""></p><p>32位单精度格式：1位符号+8位阶码+23位尾数</p><p>64位双精度格式：1位符号+11位阶码+52位尾数</p><p>IEEE754标准的长短浮点数，是尾数采取隐藏位策略的原码表示，且阶码用移码表示的浮点数。</p><p>对于规格化的二进制浮点数，数值的最高位总是”1”，既然第一位总是”1”，那么我们就不需要显式地表示它，将这个”1”隐藏，称为隐藏位，因此23位尾数可以表示出24位有效数字。</p><p>短浮点数与长浮点数都采用隐藏尾数最高数位的方法，因此可以多表示一位尾数。</p><p>对于短浮点数，偏置值为127；对于长浮点数，偏置值为1023。存储浮点数阶码之前，偏置值要先加到阶码真值上。因此，IEEE754标准中，规格化短浮点数的真值为：</p><script type="math/tex; mode=display">(-1)^{S}×1.M×2^{E-127}</script><p>规格化长浮点数的真值为：</p><script type="math/tex; mode=display">(-1)^{S}×1.M×2^{E-1023}</script><h6 id="4-定点、浮点表示的区别"><a href="#4-定点、浮点表示的区别" class="headerlink" title="(4) 定点、浮点表示的区别"></a>(4) 定点、浮点表示的区别</h6><p>若定点数与浮点数的字长相同，则浮点数所能表示的范围更大，但精度更低；</p><p>在定点运算中，当运算结果超出数的表示范围时，发生溢出；浮点运算中，运算结果超出尾数的表示范围却不一定溢出，只有当规格化后阶码超出所能表示的范围时，才发生溢出。</p><h6 id="5-浮点数的加减运算"><a href="#5-浮点数的加减运算" class="headerlink" title="(5) 浮点数的加减运算"></a>(5) 浮点数的加减运算</h6><p>浮点数加减运算的特点是阶码运算与尾数运算分开进行，浮点数运算分为以下几步：</p><ol><li><p>对阶</p><p>对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。</p><p>为此，先求差，然后以小阶向大阶看齐的原则，将阶码小的尾数右移，每移一位阶加1，直到两个数的阶码相等为止。尾数右移时，舍弃掉有效位会产生误差，影响精度。</p></li><li><p>尾数求和</p><p>将对阶后的尾数按定点数加减法运算规则运算。尾数以原码表示，即进行原码加减法运算，或将原码转换为补码运算后，再将结果转换回原码。</p></li><li><p>规格化</p><p>运算后的尾数不一定是规格化的，需要进一步进行规格化处理。左规一次相当于乘2，右规一次相当于除以2，需要右规时，只需进行1次。</p></li><li><p>舍入</p><p>0舍1入法；</p><p>末位恒置1法；</p><p>截断法。</p></li><li><p>溢出判断</p><p><img src="/images/计组第2章-数据的表示和运算/image-20220708114926685.png" alt=""></p></li></ol><h6 id="6-C语言中的浮点数类型"><a href="#6-C语言中的浮点数类型" class="headerlink" title="(6) C语言中的浮点数类型"></a>(6) C语言中的浮点数类型</h6><p>C语言中的<code>float</code>和<code>double</code>类型分别对应于IEEE754单精度浮点数和双精度浮点数，<code>long double</code>类型对应于扩展双精度浮点数。在C程序中等式的赋值和判断中会出现强制类型转换，以<code>char-&gt;int-&gt;long-&gt;double</code>和<code>float-&gt;double</code>最为常见，从前到后范围和精度都从小到大，转换过程没有损失。</p><p><code>int</code>转换为<code>float</code>时，两者都是4个字节，不会发生溢出，但是由于<code>float</code>尾数连隐藏位一共24位，当<code>int</code>型数的第24~31位非0时，无法精确转换为24位浮点数的尾数，需要进行舍入处理，影响精度。</p><p><code>float</code>或<code>double</code>类型转换为<code>int</code>时，会直接截断，仅保留整数部分。另外<code>int</code>表示范围更小，有可能会溢出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组第1章-计算机系统概述</title>
      <link href="/2022/07/27/ji-zu-di-1-zhang-ji-suan-ji-xi-tong-gai-shu/"/>
      <url>/2022/07/27/ji-zu-di-1-zhang-ji-suan-ji-xi-tong-gai-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h3><blockquote><p>计算机系统组成（硬件+软件）</p></blockquote><h4 id="冯诺依曼基本思想"><a href="#冯诺依曼基本思想" class="headerlink" title="冯诺依曼基本思想"></a>冯诺依曼基本思想</h4><p>1.采用\”<strong>存储程序</strong>\”的工作方式:将事先编制好的程序和原始数据送入主存后才能执行，一旦程序启动，就无需操作人员的干预，计算机会自动逐条执行指令，直至程序执行结束。</p><p>2.计算机硬件系统由<strong>运算器</strong>、<strong>存储器</strong>、<strong>控制器</strong>、<strong>输入设备</strong>和<strong>输出设备</strong>5大部件组成。</p><p>3.指令和数据以同等地位存储在存储器中，形式上没有区别（均为二进制数据），CPU区分它们的依据是<strong>指令周期的不同阶段</strong>。</p><p>4.指令和数据均用二进制代码表示。指令由<strong>操作码</strong>和<strong>地址码</strong>组成。</p><h4 id="计算机功能部件"><a href="#计算机功能部件" class="headerlink" title="计算机功能部件"></a>计算机功能部件</h4><p>1.输入设备：键盘，鼠标，扫描仪，摄像机等</p><p>2.输出设备：显示器，打印机</p><p>3.存储器：分为主存储器（内存）和辅助存储器（外存）。CPU能够直接访问的是主存储器。主存储器的工作方式是按存储单元的地址进行存取。 MAR位数为地址码长度，MDR位数为存储字长。</p><blockquote><p>存储体</p><p>地址寄存器MAR</p><p>数据寄存器MDR</p><p>时序控制逻辑</p></blockquote><p>4.运算器：分为算术运算和逻辑运算。（运算器和控制器集成到同一个芯片上，称为中央处理器CPU，CPU和主存构成主机，I/O设备和外存等统称为外设。）</p><blockquote><p>算术逻辑单元ALU</p><p>累加器ACC</p><p>乘商寄存器MQ</p><p>操作数寄存器X</p><p>程序状态寄存器PSW</p><p>通用寄存器</p></blockquote><p>5.控制器：计算机的指挥中心。</p><blockquote><p>程序计数器PC：存放当前欲执行指令的地址</p><p>指令寄存器IR：存放当前的指令</p><p>控制单元CU</p></blockquote><p><img src="/images/计组第1章-计算机系统概述/78B48B19BF429509004C6EC7AAF66760.png" alt="冯诺依曼机硬件组成" style="zoom:67%;"></p><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><p>1.系统软件和应用软件</p><p>系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。</p><p>应用软件是指用户为解决某个应用领域中的各类问题而编制的程序。</p><p>2.三个级别的语言</p><p>机器语言：又称为二进制代码语言，需要编程人员记忆每条指令的二进制编码，是计算机唯一可以直接识别和执行的语言。</p><p>汇编语言：汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解，汇编语言需要经过汇编程序翻译为机器语言后才能在计算机的硬件系统上执行。</p><p>高级语言：是为方便程序设计人员写出解决问题的处理方案和解题过程的程序，高级语言需要经过编译程序编译成汇编语言，再由汇编程序翻译成机器语言才能执行。</p><blockquote><p>软件和硬件具有逻辑功能等价性</p></blockquote><p><img src="/images/计组第1章-计算机系统概述/678A13280398138D415B9429E8ADA563.png" alt="计算机层次结构" style="zoom:67%;"></p><h4 id="计算机工作原理"><a href="#计算机工作原理" class="headerlink" title="计算机工作原理"></a>计算机工作原理</h4><p>1.\”存储程序\”的工作方式</p><blockquote><p>程序执行前将程序所含的指令和数据送入主存，程序执行后自动逐条完成指令的取出和执行任务，无需操作人员干预。</p></blockquote><p>2.从源程序到可执行文件</p><p>3.程序执行过程</p><blockquote><p>程序执行过程就是数据在CPU、主存储器和I/O设备之间流动的过程，所有数据的流动都是通过总线、I/O接口等进行的。</p></blockquote><p>4.指令执行过程</p><blockquote><p>根据PC取指令、对指令进行译码、计算下条指令地址、取操作数并执行、将结果送回存储器。</p></blockquote><h4 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h4><p><strong>字长</strong>：指计算机进行一次定点整数运算所能处理的二进制数据的位数，通常与CPU的寄存器位数和加法器保持一致。</p><p><strong>数据通路带宽</strong>：指数据总线一次所能并行传送信息的位数。</p><p><strong>主存容量</strong>：主存储器所能存储信息的最大容量。MAR的位数反映存储单元的个数，MDR的位数反映可寻址范围的最大值。</p><p><strong>运算速度</strong></p><blockquote><p>吞吐量和响应时间：吞吐量指系统在单位时间内处理请求的数量。</p><p><strong>主频和CPU时钟周期</strong>：CPU时钟周期是CPU中最小的时间单位，执行指令的最小动作至少需要一个时钟周期。主频是CPU时钟周期的倒数，单位为Hz，指CPU内核工作的时钟频率，即CPU内数字脉冲信号的振荡频率。f=1/T，主频=外频×倍频。</p><p><strong>CPI</strong>：即执行一条指令所需的时钟周期数，一般计算的是平均CPI。CPI=∑(程序中各类指令的CPI×程序中该类指令的比例)</p><p>IPC(Instruction per Clock):每个时钟周期内执行的指令条数（并行）。</p><p>CPU执行时间=CPU时钟周期数/主频=(指令条数×CPI)/主频 故CPU的性能取决于3个要素：主频、CPI、指令条数。</p><p>MIPS：即每秒钟执行多少百万条指令。 MIPS=指令条数/(执行时间×10⁶)=主频/(CPI×10⁶)</p><p>MFLOPS：即每秒钟执行多少百万次浮点运算。</p></blockquote><p><img src="/images/计组第1章-计算机系统概述/image-20220706092517384.png" alt="全性能公式" style="zoom: 67%;"></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>计算机系统硬件组成</p><p><img src="/images/计组第1章-计算机系统概述/计算机硬件组成.jpg" alt="计算机硬件组成" style="zoom:67%;"></p><p>存储器层次结构（<strong>寄存器&gt;cache&gt;主存</strong>）</p><p><img src="/images/计组第1章-计算机系统概述/存储器层次结构.jpg" alt="存储器层次结构" style="zoom:67%;"></p><p>Amdahl定律</p><p><img src="/images/计组第1章-计算机系统概述/Amdahl定律.jpg" alt="Amdahl定律" style="zoom: 67%;"></p><p>易混淆知识点</p><blockquote><p>在CPU中，IR、MAR、和MDR对各类程序员都是透明不可见的。</p><p>bit：位或比特，一个二进制位即为一个比特，只能容纳一个0或者一个1。</p><p>Byte：字节，1Byte = 8bits。</p><p>字（word）与字长：字是指在计算机中作为一个整体被存取、传输、处理的一组二进制数据。一个字的位数即称为字长，32位计算机：1字=32位=4字节；64位计算机：1字=64位=8字节。</p><p>机器字长：CPU能一次处理（进行一次定点整数运算）的二进制数据的最大位数。</p><p>存储字长：指一个存储单元可容纳的二进制代码的位数，即存储器中MDR的位数。</p><p>指令字长：一个指令字中包含的二进制代码的位数。</p><p>各种字长都可变，但必须是字节的整数倍。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赤壁赋</title>
      <link href="/2022/03/19/chi-bi-fu/"/>
      <url>/2022/03/19/chi-bi-fu/</url>
      
        <content type="html"><![CDATA[<h3 id="赤壁赋"><a href="#赤壁赋" class="headerlink" title="赤壁赋"></a><a href="https://so.gushiwen.cn/shiwenv_4cac23b07849.aspx">赤壁赋</a></h3><p><a href="https://so.gushiwen.cn/authorv.aspx?name=苏轼">苏轼 </a><a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=宋代">〔宋代〕</a></p><p>　　壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。</p><p>　　于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉；余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。</p><p>　　苏子愀然，正襟危坐，而问客曰：“何为其然也？”客曰：“‘月明星稀，乌鹊南飞。’此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。”</p><p>　　苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎！且夫天地之间，物各有主，苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭。是造物者之无尽藏也，而吾与子之所共适。”</p><p>　　客喜而笑，洗盏更酌。肴核既尽，杯盘狼籍。相与枕藉乎舟中，不知东方之既白。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 诗文 </tag>
            
            <tag> 赤壁赋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛神赋</title>
      <link href="/2022/03/19/luo-shen-fu/"/>
      <url>/2022/03/19/luo-shen-fu/</url>
      
        <content type="html"><![CDATA[<h3 id="洛神赋"><a href="#洛神赋" class="headerlink" title="洛神赋"></a>洛神赋</h3><p><a href="https://so.gushiwen.cn/authorv_6c695909f577.aspx">曹植</a> <a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=两汉">〔两汉〕</a></p><p>　　黄初三年，余朝京师，还济洛川。古人有言：斯水之神，名曰宓妃。感宋玉对楚王神女之事，遂作斯赋。其词曰：</p><p>　　余从京域，言归东藩，背伊阙，越轘辕，经通谷，陵景山。日既西倾，车殆马烦。尔乃税驾乎蘅皋，秣驷乎芝田，容与乎阳林，流眄乎洛川。于是精移神骇，忽焉思散。俯则未察，仰以殊观。睹一丽人，于岩之畔。乃援御者而告之曰：“尔有觌于彼者乎？彼何人斯，若此之艳也！”御者对曰：“臣闻河洛之神，名曰宓妃。然则君王之所见，无乃是乎！其状若何？臣愿闻之。”</p><p>　　余告之曰：其形也，翩若惊鸿，婉若游龙。荣曜秋菊，华茂春松。髣髴兮若轻云之蔽月，飘飖兮若流风之回雪。远而望之，皎若太阳升朝霞；迫而察之，灼若芙蕖出渌波。秾纤得衷，修短合度。肩若削成，腰如约素。延颈秀项，皓质呈露。芳泽无加，铅华弗御。云髻峨峨，修眉联娟。丹唇外朗，皓齿内鲜。明眸善睐，靥辅承权。瓌姿艳逸，仪静体闲。柔情绰态，媚于语言。奇服旷世，骨像应图。披罗衣之璀粲兮，珥瑶碧之华琚。戴金翠之首饰，缀明珠以耀躯。践远游之文履，曳雾绡之轻裾。微幽兰之芳蔼兮，步踟蹰于山隅。于是忽焉纵体，以遨以嬉。左倚采旄，右荫桂旗。攘皓腕于神浒兮，采湍濑之玄芝。</p><p>　　余情悦其淑美兮，心振荡而不怡。无良媒以接欢兮，托微波而通辞。愿诚素之先达兮，解玉佩以要之。嗟佳人之信修兮，羌习礼而明诗。抗琼珶以和予兮，指潜渊而为期。执眷眷之款实兮，惧斯灵之我欺。感交甫之弃言兮，怅犹豫而狐疑。收和颜而静志兮，申礼防以自持。</p><p>　　于是洛灵感焉，徙倚彷徨。神光离合，乍阴乍阳。竦轻躯以鹤立，若将飞而未翔。践椒途之郁烈，步蘅薄而流芳。超长吟以永慕兮，声哀厉而弥长。尔乃众灵杂沓，命俦啸侣。或戏清流，或翔神渚，或采明珠，或拾翠羽。从南湘之二妃，携汉滨之游女。叹匏瓜之无匹兮，咏牵牛之独处。扬轻袿之猗靡兮，翳修袖以延伫。体迅飞凫，飘忽若神。凌波微步，罗袜生尘。动无常则，若危若安；进止难期，若往若还。转眄流精，光润玉颜。含辞未吐，气若幽兰。华容婀娜，令我忘餐。</p><p>　　于是屏翳收风，川后静波。冯夷鸣鼓，女娲清歌。腾文鱼以警乘，鸣玉銮以偕逝。六龙俨其齐首，载云车之容裔。鲸鲵踊而夹毂，水禽翔而为卫。于是越北沚，过南冈，纡素领，回清扬。动朱唇以徐言，陈交接之大纲。恨人神之道殊兮，怨盛年之莫当。抗罗袂以掩涕兮，泪流襟之浪浪。悼良会之永绝兮，哀一逝而异乡。无微情以效爱兮，献江南之明珰。虽潜处于太阴，长寄心于君王。忽不悟其所舍，怅神宵而蔽光。</p><p>　　于是背下陵高，足往神留。遗情想像，顾望怀愁。冀灵体之复形，御轻舟而上溯。浮长川而忘反，思绵绵而增慕。夜耿耿而不寐，沾繁霜而至曙。命仆夫而就驾，吾将归乎东路。揽騑辔以抗策，怅盘桓而不能去。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 诗文 </tag>
            
            <tag> 洛神赋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>春江花月夜</title>
      <link href="/2022/03/19/chun-jiang-hua-yue-ye/"/>
      <url>/2022/03/19/chun-jiang-hua-yue-ye/</url>
      
        <content type="html"><![CDATA[<h3 id="春江花月夜"><a href="#春江花月夜" class="headerlink" title="春江花月夜"></a>春江花月夜</h3><p><a href="https://so.gushiwen.cn/authorv_787d4a1969b8.aspx">张若虚</a> <a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=唐代">〔唐代〕</a></p><p>春江潮水连海平，海上明月共潮生。<br>滟滟随波千万里，何处春江无月明！<br>江流宛转绕芳甸，月照花林皆似霰。<br>空里流霜不觉飞，汀上白沙看不见。<br>江天一色无纤尘，皎皎空中孤月轮。<br>江畔何人初见月？江月何年初照人？<br>人生代代无穷已，江月年年望相似。<br>不知江月待何人，但见长江送流水。<br>白云一片去悠悠，青枫浦上不胜愁。<br>谁家今夜扁舟子？何处相思明月楼？<br>可怜楼上月徘徊，应照离人妆镜台。<br>玉户帘中卷不去，捣衣砧上拂还来。<br>此时相望不相闻，愿逐月华流照君。<br>鸿雁长飞光不度，鱼龙潜跃水成文。<br>昨夜闲潭梦落花，可怜春半不还家。<br>江水流春去欲尽，江潭落月复西斜。<br>斜月沉沉藏海雾，碣石潇湘无限路。<br>不知乘月几人归，落月摇情满江树。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 诗文 </tag>
            
            <tag> 春江花月夜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出师表</title>
      <link href="/2022/03/19/chu-shi-biao/"/>
      <url>/2022/03/19/chu-shi-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="出师表"><a href="#出师表" class="headerlink" title="出师表"></a>出师表</h3><p><a href="https://so.gushiwen.cn/authorv_e82a672a1ca9.aspx">诸葛亮</a> <a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=两汉">〔两汉〕</a></p><p>　　先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。</p><p>　　宫中府中，俱为一体；陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</p><p>　　侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必能裨补阙漏，有所广益。</p><p>　　将军向宠，性行淑均，晓畅军事，试用于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。</p><p>　　亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</p><p>　　臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</p><p>　　先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐托付不效，以伤先帝之明；故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</p><p>　　愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏。臣不胜受恩感激。今当远离，临表涕零，不知所言。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 出师表 </tag>
            
            <tag> 诗文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陈情表</title>
      <link href="/2022/03/19/chen-qing-biao/"/>
      <url>/2022/03/19/chen-qing-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="陈情表"><a href="#陈情表" class="headerlink" title="陈情表"></a>陈情表</h3><p><a href="https://so.gushiwen.cn/authorv_a0cdb7e44d9a.aspx">西晋·李密</a> <a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=魏晋">〔魏晋〕</a></p><p>　　臣密言：臣以险衅，夙遭闵凶。生孩六月，慈父见背；行年四岁，舅夺母志。祖母刘愍臣孤弱，躬亲抚养。臣少多疾病，九岁不行，零丁孤苦，至于成立。既无伯叔，终鲜兄弟，门衰祚薄，晚有儿息。外无期功强近之亲，内无应门五尺之僮，茕茕孑立，形影相吊。而刘夙婴疾病，常在床蓐，臣侍汤药，未曾废离。</p><p>　　逮奉圣朝，沐浴清化。前太守臣逵察臣孝廉；后刺史臣荣举臣秀才。臣以供养无主，辞不赴命。诏书特下，拜臣郎中，寻蒙国恩，除臣洗马。猥以微贱，当侍东宫，非臣陨首所能上报。臣具以表闻，辞不就职。诏书切峻，责臣逋慢；郡县逼迫，催臣上道；州司临门，急于星火。臣欲奉诏奔驰，则刘病日笃，欲苟顺私情，则告诉不许：臣之进退，实为狼狈。</p><p>　　伏惟圣朝以孝治天下，凡在故老，犹蒙矜育，况臣孤苦，特为尤甚。且臣少仕伪朝，历职郎署，本图宦达，不矜名节。今臣亡国贱俘，至微至陋，过蒙拔擢，宠命优渥，岂敢盘桓，有所希冀！但以刘日薄西山，气息奄奄，人命危浅，朝不虑夕。臣无祖母，无以至今日，祖母无臣，无以终余年。母孙二人，更相为命，是以区区不能废远。</p><p>　　臣密今年四十有四，祖母今年九十有六，是臣尽节于陛下之日长，报养刘之日短也。乌鸟私情，愿乞终养。臣之辛苦，非独蜀之人士及二州牧伯所见明知，皇天后土实所共鉴。愿陛下矜愍愚诚，听臣微志，庶刘侥幸，保卒余年。臣生当陨首，死当结草。臣不胜犬马怖惧之情，谨拜表以闻。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 诗文 </tag>
            
            <tag> 陈情表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滕王阁序</title>
      <link href="/2022/03/19/teng-wang-ge-xu/"/>
      <url>/2022/03/19/teng-wang-ge-xu/</url>
      
        <content type="html"><![CDATA[<p><strong>滕王阁序</strong></p><p><a href="https://so.gushiwen.cn/authorv_e6b970da08cd.aspx">王勃</a> <a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=唐代">〔唐代〕</a></p><p>　　豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p><p>　　时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿。临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p><p>　　披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨，雁阵惊寒，声断衡阳之浦。</p><p>　　遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人；萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？</p><p>　　嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p><p>　　勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p><p>　　呜呼！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔。<br>　　滕王高阁临江渚，佩玉鸣鸾罢歌舞。<br>　　画栋朝飞南浦云，珠帘暮卷西山雨。<br>　　闲云潭影日悠悠，物换星移几度秋。<br>　　阁中帝子今何在？槛外长江空自流。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 诗文 </tag>
            
            <tag> 滕王阁序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
